This file was created in Emacs with org-mode installed.
To have full functionality, please install Emacs with your package manager and see HOW_TO_INSTALL_ORG_MODE
Refer to the video 14 in the following class if needed: https://www.skillshare.com/classes/The-Free-Linux-Bin/1454905790 

:HOW_TO_INSTALL_ORG_MODE:
Pressing TAB on the above line should fold the content, if not ORG is not installed.

  Make sure the following code is present and at the top of your ~/.emacs file
  #+BEGIN_CODE
(package-initialize)
;; load emacs 24's package system. Add MELPA repository.
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   ;; 1 of the 2 next line needs to be there.
   ;;'("melpa" . "http://stable.melpa.org/packages/")
   '("melpa" . "http://melpa.milkbox.net/packages/")
   )
  (add-to-list 'package-archives    '("org" . "https://orgmode.org/elpa") t)
  )

  #+END_CODE

  Restart emacs

  Press M-x package-list-packages
  scroll down to org
  While on that line, press i then press x
  Confirm that you want to install

  Restart Emacs to be sure and the file will look way better.
:END:

:README:
How to operate org files.
Lines starting with 1 or more * are headers, press TAB while on a header, you will cycle its visibility.

src code block are contained within #+BEGIN_SRC and #+END_SRC, pressing TAB on either of those line will cycle its visiblity
You can evaluate the code within emac with the following:
C-c C-c within a code block will evaluate and display the results when possible.

You can export any code with the following:
C-c C-v t export all code block
C-u C-c C-v t export current code block (Where cursor is located)

Code block are export with the filename given in header :tangle. They are exported and are executable ready to use.

To edit a code block press C-' while your cursor is inside or on the header/footer of a src block.
A new buffer will open with the content of the block.
Instruction will be provided on top of new buffer on how to save and exit or cancel and exit.


I strongly recommend that you play with all code block. Modify them, run them, break them.
If you are not comfortable with org mode and prefer to use your text editor, export all code right now, no matter where your cursor is and hack away in comfort.
I also recommend you make copies of the original src block before changing it.
You can copy the whole code block when it is folded by placing the cursor at the begining of the line and press M-w (M = META, usually ALT)
M-w copies the line and press C-y to paste it.
Change the filename value assigned to :tangle and your code will be exported when requested.

Last important rule, when you see a README, Read it!
:END:

A good source of information: https://tldp.org


* Special char
** ?
*** As a test operator
   Within certains expression, the ? indicates a test for a condition.
   In a double-parentheses construct it can serve as a C-style trinary operation
   #+BEGIN_SRC bash :results output :export code :tangle testOperator.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     v0=1
     v1=2
     declare -i v2

     # The following if statement would assign v2 to either 3 or 0.
     # This will cause the sequence to become 1 2 3
     # If you invert v1 & v0, the sequence would be 2 1 0

     #if [[ $v0 < $v1 ]]; then
     #    v2=3
     #else
     #    v2=0
     #fi

     ## This does the same thing
     (( v2 = v0<v1?3:0 ))
     #            ^ ^

     echo $v0 $v1 $v2
   #+END_SRC

   #+RESULTS:
   : 1 2 3

*** Test if variable has been set.
    In a Parameter substitution expression, it can test wheter a variable has been set
    Structure: ${PARAM?ERR_MSG}, ${PARAM:?ERR_MSG}
    If PARAM is set, use it, else print ERR_MSG and abort with exit 1
    Both structure are almost the same, see code for demonstration
    NOTE: Export the next code: C-u C-c C-v t
    #+BEGIN_SRC bash eval:no :export code :tangle testIfVarIsSet.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      var1="hello"
      declare var2

      echo "--------------------"
      echo "Our variables are set:"
      echo -e "\e[32mvar1: \e[0m$var1"
      echo -e "\e[32mvar2\e[0m is declared but not set."
      echo -e "\e[32mvar3\e[0m does not exists except for the test."
      echo "--------------------"

      echo 'This test uses the following format: ${PARAM?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var1?"var1 is not set"}'"\e[0m"
      echo "The test will evaluate to true and the script will continue."
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var1?"var1 is  not set"}
              echo "var1 is set: $var1"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var2?"var2 is not set"}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2?"var2 is  not set"}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo "This test is the same as the previous one, except we do not provide ERR_MSG"
      echo -e "This test code: \e[33m"'${var2?}'"\e[0m"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2?}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM?}'
      echo -e "This test code: \e[33m"'${var3?}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var3?"var3 is  not set"}
              echo "var3 is set: $var3"
              ;;
      esac

      echo
      echo

      echo "--------------------"
      echo 'Now we look at the other format: ${PARAM:?ERR_MSG}'
      echo "The : makes a difference when PARAM has been declared an is null"
      echo "First lets redo our first test with the ':' variation. "
      echo -e "This test code: \e[33m"'${var1:?"var1 is not set"}'"\e[0m"
      echo "The test will evaluate to true and the script will continue."
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var1:?"var1 is  not set"}
              echo "var1 is set: $var1"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM:?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var2:?"var2 is declared bu not set"}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2:?"var2 is declare but not set"}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo "This test is the same as the previous one, except we do not provide ERR_MSG"
      echo -e "This test code: \e[33m"'${var2:?}'"\e[0m"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2:?}
              echo "var2 is set: $var2"
              ;;
      esac
    #+END_SRC


* Parameter substitution
  Manipulating, expanding variable
  ${PARAM}
  In most case, same as $PARAM, it refers to the value of PARAM. In certain context, only the less ambiguous ${PARAM} works.
  If you seem to have issue with the value of a variable, attempt the parameter substitution ${PARAM}
  It can be used to concatenate strings.
  #+BEGIN_SRC bash :results output :exports code :tangle paramSub.sh :tangle-mode (identity #o0755) :cmdline 2>&1
    #!/bin/bash
    declare myFullString part1 part2
    part1="Hello world, "
    part2="learning python?"
    myFullString=${part1}"Bash is hard, have you considered "${part2}
    echo $myFullString
  #+END_SRC

  #+RESULTS:
  : Hello world, Bash is hard, have you considered learning python?

  We can use parameter substitution to set a default value.
  ${PARAM-DEFAULT}, ${PARAM:-DEFAULT}
  In the above structure if PARAM is not set, DEFAULT is used.
  #+BEGIN_SRC bash :results output :exports code :tangle defaultParam.sh :tangle-mode (identity #o0755) :cmdline 2>&1
    #!/bin/bash

      declare myFullString part1 part2
      part1="Hello world, "
      # This first example demonstrate the ${PARAM-DEFAULT} format, notice that part2 is declare but not set.
      myFullString=${part1}"Bash is hard, have you considered "${part2-"washing windows?"}
      echo $myFullString

      part3=
      # This first example demonstrate the ${PARAM:-DEFAULT} format
      # notice that part3 has been declared and would be null right now.
      myFullString=${part1}"Bash is hard, have you considered "${part3-"not giving up"} # This will not echo, part3 is in a sense set to NULL
      echo $myFullString

      myFullString=${part1}"Bash is hard, have you considered "${part3:-"not giving up"} # This will work
      echo $myFullString


      ## Another variable value can be used.
      replacement="that it also means it is powerfull"
      myFullString=${part1}"Bash is hard, have you considered "${part2-$replacement} # Notice the $ before replacement.

      echo $myFullString
  #+END_SRC

  #+RESULTS:
  : Hello world, Bash is hard, have you considered washing windows?
  : Hello world, Bash is hard, have you considered
  : Hello world, Bash is hard, have you considered not giving up
  : Hello world, Bash is hard, have you considered that it also means it is powerfull

  Another variance exists
  ${PARAM=DEFAULT}, ${PARAM:=DEFAULT}
  #+BEGIN_SRC bash :results output :exports code :tangle defaultParamVariation.sh :tangle-mode (identity #o0755) :cmdline 2>&1
    #!/bin/bash

      declare myFullString part1 part2
      part1="Hello world, "
      echo ${part1="Good bye."}
      echo ${part2="See you soon."}
  #+END_SRC

  #+RESULTS:x
  : Hello world,
  : See you soon.

  Let's do things a little backward shall we?
  ${PARAM+ALT_VALUE}, ${PARAM:+ALT_VALUE}
  If PARAM IS set, use ALT_VALUE otherwise, use null string.
  ':' makes a difference when PARAM has been declared and IS null.
  #+BEGIN_SRC bash :results output :exports code :tangle paramAltVal.sh :tangle-mode (identity #o0755) :cmdline 2>&1
    #!/bin/bash
    var1="hello"
    echo ${var1+"World"} # This will echo World
    echo ${var2+"World"} # This will echo null
  #+END_SRC

  #+RESULTS:

  let's not forget the usage from Special char section:
  :VARIABLEISSET:
  Test if variable has been set.
    In a Parameter substitution expression, it can test wheter a variable has been set
    Structure: ${PARAM?ERR_MSG}, ${PARAM:?ERR_MSG}
    If PARAM is set, use it, else print ERR_MSG and abort with exit 1
    Both structure are almost the same, see code for demonstration
    NOTE: Export the next code: C-u C-c C-v t
    #+BEGIN_SRC bash eval:no :export code :tangle testIfVarIsSet.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      var1="hello"
      declare var2

      echo "--------------------"
      echo "Our variables are set:"
      echo -e "\e[32mvar1: \e[0m$var1"
      echo -e "\e[32mvar2\e[0m is declared but not set."
      echo -e "\e[32mvar3\e[0m does not exists except for the test."
      echo "--------------------"

      echo 'This test uses the following format: ${PARAM?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var1?"var1 is not set"}'"\e[0m"
      echo "The test will evaluate to true and the script will continue."
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var1?"var1 is  not set"}
              echo "var1 is set: $var1"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var2?"var2 is not set"}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2?"var2 is  not set"}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo "This test is the same as the previous one, except we do not provide ERR_MSG"
      echo -e "This test code: \e[33m"'${var2?}'"\e[0m"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2?}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM?}'
      echo -e "This test code: \e[33m"'${var3?}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var3?"var3 is  not set"}
              echo "var3 is set: $var3"
              ;;
      esac

      echo
      echo

      echo "--------------------"
      echo 'Now we look at the other format: ${PARAM:?ERR_MSG}'
      echo "The : makes a difference when PARAM has been declared an is null"
      echo "First lets redo our first test with the ':' variation. "
      echo -e "This test code: \e[33m"'${var1:?"var1 is not set"}'"\e[0m"
      echo "The test will evaluate to true and the script will continue."
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var1:?"var1 is  not set"}
              echo "var1 is set: $var1"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM:?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var2:?"var2 is declared bu not set"}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2:?"var2 is declare but not set"}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo "This test is the same as the previous one, except we do not provide ERR_MSG"
      echo -e "This test code: \e[33m"'${var2:?}'"\e[0m"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2:?}
              echo "var2 is set: $var2"
              ;;
      esac
    #+END_SRC
  :END:

** A good use for Parameter substitution
   Let's say you have a script that requires arguments, it should not be called without it.
   With this one line, if the script is called without an argument, it exit with an error message.
   #+BEGIN_SRC bash :results output :exports code :tangle parSubUsage.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     : ${1?"This scripts needs an argument."}

     echo "Script is done."
   #+END_SRC

   #+RESULTS:


* Command substitution
  Command substitution takes the output of 1 or more commands and plugs it into another context.
  #+BEGIN_SRC bash :results output :exports code :tangle commandSub.sh :tangle-mode (identity #o0755) :cmdline 2>&1
    #!/bin/bash

    # Consider the following:
    echo
    echo "------------"
    echo "ls -l"
    echo 'ls -l'
    echo ls -l
    echo `ls -l`

    # Command substitution can be place within backtick ``
    # Find more details in my the following class https://skl.sh/2zQFWZA


    ## Command output can be assigned to a variable
    echo
    echo "------------"
    echo "Assign ip addr to myNetCardInfo"
    myNetCardInfo=`ip addr`
    printf "$myNetCardInfo" # Notice this prints newline properly.


    echo
    echo "------------"
    echo "Using command substitution to control a for loop"
    # You can used command substitution to control loops.
    for i in `ls -A /var/log`; do
        if [ -f /var/log/$i ]; then
           echo $i
        fi
    done

    echo
    echo "------------"
    echo "I like better to use process substituion, more on that in this class: https://skl.sh/2zQFWZA"

    # I think process substitution makes for cleaner
    while read -r file; do
        if [ -f /var/log/$file ]; then
            echo $file
        fi
    done < <(ls -A /var/log)
  #+END_SRC

  #+RESULTS:
  #+begin_example

  ------------
  ls -l
  ls -l
  ls -l
  total 196 -rwxr-xr-x 1 tech papa 528 Dec 17 14:17 defaultParam.sh -rwxr-xr-x 1 tech papa 532 Dec 18 16:13 envVar.sh -rw-r--r-- 1 tech papa 49571 Dec 18 16:22 #notes.org# -rw-r--r-- 1 tech papa 46596 Dec 18 16:20 notes.org -rw-r--r-- 1 tech papa 79213 Dec 17 08:39 notes.org~ -rwxr-xr-x 1 tech papa 217 Dec 17 16:53 remLed0.sh -rwxr-xr-x 1 tech papa 3489 Dec 18 10:23 testIfVarIsSet.sh

  ------------
  Assign ip addr to myNetCardInfo
  1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
      inet 127.0.0.1/8 scope host lo
         valid_lft forever preferred_lft forever
      inet6 ::1/128 scope host 
         valid_lft forever preferred_lft forever
  2: enp0s25: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
      link/ether 3c:97:0e:17:7d:a7 brd ff:ff:ff:ff:ff:ff
  3: wlp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
      link/ether 8c:70:5a:f2:79:84 brd ff:ff:ff:ff:ff:ff
      inet 192.168.0.10/24 brd 192.168.0.255 scope global dynamic noprefixroute wlp3s0
         valid_lft 594392sec preferred_lft 594392sec
      inet6 fd00:f81d:f7b:de22:21f4:ff5:82f9:ff7f/64 scope global temporary dynamic 
         valid_lft 523852sec preferred_lft 5175sec
      inet6 fd00:f81d:f7b:de22:6564:c5ea:35d1:efa/64 scope global temporary deprecated dynamic 
         valid_lft 437732sec preferred_lft 0sec
      inet6 fd00:f81d:f7b:de22:89d3:c25:6259:b466/64 scope global temporary deprecated dynamic 
         valid_lft 351611sec preferred_lft 0sec
      inet6 fd00:f81d:f7b:de22:b72:c972:69a6:65c2/64 scope global dynamic mngtmpaddr noprefixroute 
         valid_lft 535428sec preferred_lft 401571sec
      inet6 fe80::b1d:6c8d:bed3:9ea6/64 scope link noprefixroute 
         valid_lft forever preferred_lft forever
  6: wwp0s20u4i6: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
      link/ether 02:80:37:ec:02:00 brd ff:ff:ff:ff:ff:ff
  ------------
  Using command substitution to control a for loop
  alternatives.log
  alternatives.log.1
  apport.log
  apport.log.1
  apport.log.2.gz
  apport.log.3.gz
  auth.log
  auth.log.1
  auth.log.2.gz
  auth.log.3.gz
  auth.log.4.gz
  boot.log
  bootstrap.log
  btmp
  btmp.1
  dpkg.log
  dpkg.log.1
  faillog
  fontconfig.log
  gpu-manager.log
  kern.log
  kern.log.1
  kern.log.2.gz
  kern.log.3.gz
  kern.log.4.gz
  lastlog
  syslog
  syslog.1
  syslog.2.gz
  syslog.3.gz
  syslog.4.gz
  syslog.5.gz
  syslog.6.gz
  syslog.7.gz
  tallylog
  wtmp
  wtmp.1
  Xorg.0.log
  Xorg.0.log.old
  Xorg.1.log
  Xorg.1.log.old
  Xorg.2.log
  Xorg.2.log.old

  ------------
  I like better to use process substituion, more on that in this class: https://skl.sh/2zQFWZA
  alternatives.log
  alternatives.log.1
  apport.log
  apport.log.1
  apport.log.2.gz
  apport.log.3.gz
  auth.log
  auth.log.1
  auth.log.2.gz
  auth.log.3.gz
  auth.log.4.gz
  boot.log
  bootstrap.log
  btmp
  btmp.1
  dpkg.log
  dpkg.log.1
  faillog
  fontconfig.log
  gpu-manager.log
  kern.log
  kern.log.1
  kern.log.2.gz
  kern.log.3.gz
  kern.log.4.gz
  lastlog
  syslog
  syslog.1
  syslog.2.gz
  syslog.3.gz
  syslog.4.gz
  syslog.5.gz
  syslog.6.gz
  syslog.7.gz
  tallylog
  wtmp
  wtmp.1
  Xorg.0.log
  Xorg.0.log.old
  Xorg.1.log
  Xorg.1.log.old
  Xorg.2.log
  Xorg.2.log.old
  #+end_example

* Variable
** Variable length
   ${#var} returns the number of character in $var
   If var is an array, it return the length of the first element.
   ${#var[@]} OR ${#var[*]}to return number of items in var array
   ${#@} OR ${#*} returns the number of positional parameters.
   Change the result of the last echo command by changing :cmdline args, make sure to leave 2>&1.
   #+BEGIN_SRC bash :results output :exports code :tangle varLength.sh :tangle-mode (identity #o0755) :cmdline p1 p2 2>&1
     #!/bin/bash

     var1="hello"
     echo "var1 length: ${#var1}"

     declare -a var2
     var2=("bye" "hello")
     echo '${#var2'}" length: ${#var2}"
     ## This is the same
     echo '${#var2[0]}'" length: ${#var2[0]}"

     echo "var2 has ${#var2[@]} items."

     ## Checking positional parameters
     echo "You have provided ${#@} parameters."
   #+END_SRC

   #+RESULTS:

** Substring removal
   ${var#PATTERN} Remove from $var the SHORTEST part of PATTERN that matches the front end of $var
   #{var##PATTERN} Remove from $var the LONGEST part of PATTERN that matches the front end of $var
   Here is a simple function that remove leading zero from arg given through :cmdline
   #+BEGIN_SRC bash :results output :exports code :tangle remLed0.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     var1=abcd0123ef12d34c3213
     pattern1=a*d # This will match everything from a to d
     pattern2=b*d # This will match everything from b to d, but b needs to be the first character.
     pattern3=*b*d # This will match everything from b to d and will include anything infront of b
     pattern4=abcd*34
     pattern5=a*d*34 #same as above.

     echo "Number of char in var1: ${#var1}"

     echo "${var1#$pattern1}" # This will remove abcd, leaving: 0123ef12d34c3213
     echo "${var1##$pattern1}" # This will remove abcd, leaving: 34c3213


     # Those will not remove anything.
     # This is because we search from the beginning, there is no matching part at the start of the variable.
     # In a sense, if you are familiar with regex, it has a similar behavior to ^b*d
     echo "${var1#$pattern2}"
     echo "${var1##$pattern2}"

     # This pattern on the other hand will work
     # This produce the same results as our first attempt whit pattern1
     echo "${var1#$pattern3}"
     echo "${var1##$pattern3}"

     # Both of those will leave c3213
     echo "${var1#$pattern4}"
     echo "${var1##$pattern4}"

     # Same as above
     echo "${var1#$pattern5}"
     echo "${var1##$pattern5}"
   #+END_SRC

   #+RESULTS:

   ${var%PATTERN} Remove from $var the SHORTEST part of PATTERN that matches the back end of $var
   #{var%%PATTERN} Remove from $var the LONGEST part of PATTERN that matches the back end of $var
   #+BEGIN_SRC bash :results output :exports code :tangle remLed0.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     var1=abcd0123ef12d34c3213
     pattern1=3*13
     pattern2=34
     pattern3=34*
     pattern4=*3213
     pattern5=23*d*c*

     echo "Number of char in var1: ${#var1}"

     echo
     echo "--------------------"
     echo "Pattern1: $pattern1"
     echo "${var1%$pattern1}"
     echo "${var1%%$pattern1}"

     echo
     echo "--------------------"
     echo "Pattern2: $pattern2"
     echo "${var1%$pattern2}"
     echo "${var1%%$pattern2}"


     echo
     echo "--------------------"
     echo "Pattern3: $pattern3"
     echo "${var1%$pattern3}"
     echo "${var1%%$pattern3}"


     echo
     echo "--------------------"
     echo "Pattern4: $pattern4"
     echo "${var1%$pattern4}"
     echo "${var1%%$pattern4}"


     echo
     echo "--------------------"
     echo "Pattern5: $pattern5"
     echo "${var1%$pattern5}"
     echo "${var1%%$pattern5}"
   #+END_SRC

   #+RESULTS:

** Variable expansion

    The following format will expand var starting a pos
    ${var:pos}
    #+BEGIN_SRC bash :results output :exports code :tangle expandVarFromPos.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash


      var1="0123456789"

      echo
      echo "---------"
      echo 'Running $var1:0'
      echo "${var1:0}"

      echo
      echo "---------"
      echo 'Running $var1:3'
      echo "${var1:3}"
    #+END_SRC

    #+RESULTS:
    : 
    : ---------
    : Running $var1:0
    : 0123456789
    : 
    : ---------
    : Running $var1:0
    : 3456789

    Expand max len char of var starting at pos
    ${var:pos:len}
    #+BEGIN_SRC bash :results output :exports code :tangle expandVarMax.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      var1="0123456789"

      echo '$var1: '"$var1"
      echo
      echo "----------"
      echo 'Running ${var1:0:4}'
      echo "${var1:0:4}"

      echo
      echo "----------"
      echo 'Running ${var1:1:4}'
      echo "${var1:1:4}"

      echo
      echo "----------"
      echo 'Running ${var1:3:20}, notice no error or warning.'
      echo "${var1:3:20}"
    #+END_SRC

    #+RESULTS:

    This last format can be quite useful.
    Matches names of all previously declared variables beginning with varprefix.
    ${!varprefix*}, ${!varprefix@}
    #+BEGIN_SRC bash :results output :exports code :tangle varPrefix.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      var1="hello"
      var2="World"
      declare var3

      a=${!va*} # var3 is NOT part of this.
      echo "$a" # Display var1 var2
      for var in ${a[@]}; do # Loop through each space separated
          echo '$'"$var: ${!var}" # Derefencing the variables in $a[@]
      done


    #+END_SRC

    #+RESULTS:

** Substring replacement
    The following format will replace the FIRST match of PATTERN with REPLACEMENT with VAR
    If you do not provide a REPLACEMENT, PATTERN will be delete from VAR
    ${VAR/PATTERN/REPLACEMENT}

    #+BEGIN_SRC bash :results output :exports code :tangle subRep.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      var1="0123456789"

      echo '$var1: '"$var1"

      var2="${var1/345/-Hello-}"
      echo '$var2: '"$var2"

      var3="${var2/Hello/}"
      echo '$var3: '"$var3"

    #+END_SRC

    #+RESULTS:

    This next format, is the same, except it will replace ALL match found.
    #+BEGIN_SRC bash :results output :exports code :tangle subRep.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      var1="0123456789 N0w I c0unt Backward 9876543210"

      echo '$var1: '"$var1"

      var2="${var1//345/-Hello-}"
      echo '$var2: '"$var2"

      var3="${var2//0/Zero}"
      echo '$var3: '"$var3"

    #+END_SRC

    #+RESULTS:

    Next format will replace Pattern with Replacement in var if Pattern is at the start of var
    ${var/#Pattern/Replacement}

    Next format will replace Pattern with Replacement in var if Pattern is at the end of var
    ${var/%Pattern/Replacement}

    #+BEGIN_SRC bash :results output :exports code :tangle prefRep.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      var1="0123456789_abcdef-ABCDEF-01234"
      echo '$var1: '"$var1"

      echo
      echo "---------"
      echo 'Running: ${var1/#01234/ABCD}'
      newvar=${var1/#01234/ABCD} # Matches 01234 if at the begining of the string
      echo $newvar

      echo
      echo "---------"
      echo 'Running: ${var1/%01234/ABCD}'
      newvar2=${var1/%01234/ABCD} # Matches 01234 if at the end of the string
      echo $newvar2

    #+END_SRC

    #+RESULTS:


** Environment variable
   Let's play with what we learned and create a script that will display system information to stdout
   #+BEGIN_SRC bash :results output :exports code :tangle envVar.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     # This loop is control by input redirection & process substitution.
     # I provide read with -r to ensure no characters gets escaped.
     while  read -r line; do
         var="${line%=*}"
         val="${line#*=}"

         # Here we create a variable from expanding m_$var and assign $val to it.
         # Each environment variable will be assign a m_variable=value in this script.
         # DO NOT ASSIGN ${var}=${val} we are playing with environment variable.
         eval "m_${var}=${val}" >/dev/null 2>&1 # I don't want output to the screen.

         if [[ $? > 0 ]]; then # Eval return > 0 we have an error
             # In evaluation mode, PATH does not work good, silence it.
             # I don't plan on using this variable, plus in terminal mode it works.
             # I should figure out why, but I got more important thing to teach you.
             if [[ "${var}" == "PATH" ]]; then
                 echo 1 > /dev/null
             else
                 2>&1 echo "Error creating m_$var"
             fi
         fi


     done < <(printenv)
     #      ^---------^ Process substitution
     #    ^ Redirecting input

     ## Now let's look for some specific local variable.
     ## Before we print them, we first need to make sure they exists.
     ## Yes there are better ways to do this, but lets play with what we learned.
     if [[ ${!m_DISPLAY*} ]]; then
         echo "Your xserver display variable: $m_DISPLAY"
     else
         echo "You don't seem to be running an X server."
     fi

     if [[ ${!m_LANG*} ]]; then
         echo "LANG set to $m_LANG"
     fi

     if [[ ${!m_DESKTOP_SESSION*} ]]; then
        case $m_DEKSTOP_SESSION in
            "XFCE")
                echo "You are running XFCE"
                ;;
            ,*)
                echo "You are running $m_DESKTOP_SESSION"
                ;;
        esac
     fi
     echo "User: "${m_USER-"UNKNOWN???"}

     ## When you run inside emacs, there is an env variable set.
     ## But when using org evaluation, this variable is not returned from printenv.
     ## Should you export the code, it will report properly.
     if [[ ${!m_INSIDE_EMACS*} ]]; then
         echo "Var Inside emacs is set, you must be running emacs."
     fi

     if [[ ${!m_TERM*} ]]; then
         if [[ "$m_TERM" = "dumb" ]]; then
            echo "You are running a dumb teminal"
         fi
     fi

     ## Unset all variables
     a=${!m_*}
     echo
     echo "---------"
     echo "Unset all variable in this script..."
     for i in ${a[@]}; do
         echo "Unset $i"
         unset $i
     done

   #+END_SRC

   #+RESULTS:

* Projects

:README:
You will learn more tricks by looking at my version of the project.
Some missing bash notion can create some challenges doing this project. This is normal, we just started scripting.
For example, select splits the list based on a bash variable IFS. IFS default setting is space.
This cause select for each word in mainMenu. To fix this behavior, we set IFS to ; before our main loop.
Unsetting IFS will reset to its default behavior.
:END:

** Create a simple file manager

Most of the src code below cannot run in evaluation mode without changin src block headers.
To export, place your cursor below #+NAME: scriptExport and press C-u C-c C-v t
Attempting to export on any other code block will not work. This is a setup that allows exportation of the project only without export all code block.
The project will also export when exporting all code block.

#+NAME: scriptExport
#+BEGIN_SRC bash :eval no :tangle myFm.sh :tangle-mode (identity #o0755) :noweb tangle
  #!/bin/bash

  <<scriptHeader>>

  <<exitDirectory>>

  <<enterDirectory>>

  <<listContent>>

  <<createDirectory>>

  <<removeDirectory>>

  <<createFile>>

  <<removeFile>>

  <<QUIT>>

  <<Main>>
#+END_SRC

#+NAME: Main
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :noweb strip-export :export no
  ###
  # To allow for our enterDirectory function to have a "Up" feature. Our directory stack need to have every part from the root folder.
  # If we don't, the script will be restricted to the current directory and below.
  # This is because the directory stack base entry will be the current directory. Any attempt to popd this entry will not result in the parent directory
  # Note that our current directory will remain at the base of the stack
  currentTree=$(pwd)
  IFS=/
  echo "Clear the directory stack."
  dirs -c
  if [[ $? > 0 ]]; then
      >&2 echo "Error clearing directory stack. Cannot continue."
      exit 1
  fi

  echo "Rebuilding it."
  first=0 # our first pushd requires a / in front.
  for part in $currentTree; do
      if [[ $first > 0 ]]; then
          pushd $part
      else
          pushd "/$part"
          first=1
      fi
  done
  unset IFS
  echo $currentTree
  IFS=;
  while true; do
      select OPT in ${mainMenu[@]}; do
          case $OPT in
              "List Content")
                  listContent
                  ;;
              "Create File")
                  createFile
                  ;;
              "Create Directory")
                  createDirectory
                  ;;
              "Remove File")
                  removeFile
                  ;;
              "Remove Directory")
                  removeDirectory
                  ;;
              "Enter Directory")
                  enterDirectory
                  ;;
              "Quit")
                  Quit
                  ;;
              ,*)
                  >&2 echo "Selection not understood."
                  ;;
          esac
      done
  done
#+END_SRC

#+NAME: scriptHeader
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  declare -f enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit
  declare -a mainMenu=("List Content" "Enter Directory" "Create File" "Create Directory" "Remove File" "Remove Directory" "Quit")
#+END_SRC

#+NAME: exitDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function exitDirectory {
      popd >/dev/null # pop the top of the stack
  }

#+END_SRC

#+NAME: enterDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function enterDirectory {
      select DIR in "UP" */ "Back"; do
          case $DIR in
              "UP")
                  popd
                  break;
                  ;;
              "Back")
                  break
                  ;;
              ,*)
                  pushd $DIR
                  break;
                  ;;
          esac
      done
  }

#+END_SRC

#+NAME: listContent
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  # Called without arguments, list the content in current directory
  # Called with an argument, list the content if arg is directory
  # Complains if arg is otherwise.
  function listContent {
      if [ -z $1 ]; then
         ls -l
         return 0
      fi
      if [ -d $1 ]; then
          enterDirectory $1
          ls -l
          exitDirectory
          return 0
      fi
      >&2 echo "Error, listContent argument not understood."
      return 1
  }

#+END_SRC

#+NAME: createDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function createDirectory {
      echo -n "Enter directory name: "
      read n # read user input into var n
      if [ -f $n ]; then # File exists
          >&2 echo "Error file exists."
          return 1
      fi
      eval "mkdir -vp $n" # Attempt to create the directory
      if (( $? > 0 )); then # Return value of eval is stored in $?
          # >&2 redirects output into stderr.
          # It is good practice to redirect error message to stderr (file descriptor 2)
          >&2 echo "eval mkdir -vp $1 returned an error."
          return 1 # Return error
      fi
      echo "Directory $n created."
      return 0 # Success
  }
#+END_SRC

#+NAME: removeDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeDirectory {
      select file in * "QUIT"; do
          if [[ "$file" == "QUIT" ]]; then
              echo "Leaving."
              return 0
          fi
          if [ ! -e $file ]; then
              echo "$file does not exists."
              return 1
          fi
          if [ -f $file ]; then
              echo "$file is a regular file, doing nothing."
              return 2
          fi
          if [ -d $file ]; then
              # Checking if directory is empty
              cCount=eval "ls -A $file | wc -l"
              if [[ $cCount > 0 ]]; then
                  echo "Warning, directory not empty, doing nothing."
                  return 3
              fi
              eval "rmdir -iv $file"
              if [[ $? > 0 ]]; then
                  echo "Error with eval comand to remove directory."
                  return 4
              fi
              return 0
          fi
          >&2 echo "Unknown error, but file was not deleted."
          return 127
      done
  }
#+END_SRC

#+NAME: createFile
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function createFile {
      echo -n "Enter file name: "
      read n # read user input into var n
      if [ -e $n ]; then # File exists
          >&2 echo "Error file exists."
          return 1
      fi
      eval "touch $n" # Attempt to create the directory
      if (( $? > 0 )); then # Return value of eval is stored in $?
          # >&2 redirects output into stderr.
          # It is good practice to redirect error message to stderr (file descriptor 2)
          >&2 echo "eval touch -vp $1 returned an error."
          return 1 # Return error
      fi
      echo "File $n created."
      return 0 # Success
  }
#+END_SRC

#+NAME: removeFile
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeFile {
      select file in * "QUIT"; do
          if [[ "$file" == "QUIT" ]]; then
              echo "Leaving."
              return 0
          fi
          if [ ! -e $file ]; then
              echo "$file does not exists."
              return 1
          fi
          if [ -d $file ]; then
              echo "$file is a directory file, doing nothing."
              return 2
          fi
          if [ -f $file ]; then
              echo -e "\e[33mWARNING, THIS WILL REALLY DELETE THE FILE\e[0m"
              eval "rm -iv $file"
              if [[ $? > 0 ]]; then
                  echo "eval returned and error."
                  return 3
              fi
              echo "File deleted."
              return 0
          fi
          >&2 echo "Unknown error, but file was not deleted."
          return 3
      done
  }
#+END_SRC

#+NAME: QUIT
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function Quit {
      echo "Cleaning up."
      unset  enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit mainMenu
      exit 0
  }
#+END_SRC





** Here is another version, making more use of the select builtin

Most of the src code below cannot run in evaluation mode without changin src block headers.
To export, place your cursor below #+NAME: scriptExport and press C-u C-c C-v t
Attempting to export on any other code block will not work. This is a setup that allows exportation of the project only without export all code block.
The project will also export when exporting all code block.

#+NAME: scriptExport2
#+BEGIN_SRC bash :eval no :tangle myFm2.sh :tangle-mode (identity #o0755) :noweb tangle
  #!/bin/bash

  <<scriptHeader2>>

  <<exitDirectory2>>

  <<enterDirectory2>>

  <<listContent2>>

  <<createDirectory2>>

  <<createFile2>>

  <<rename>>

  <<removeDirectory2>>

  <<removeFile2>>

  <<enableSub>>
  
  <<createSub>>

  <<QUIT2>>

  <<Main2>>
#+END_SRC

#+NAME: scriptHeader2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  declare -f enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit
  ## Simple hack to display colored item in select.
  declare -a mainMenu=("Reload" "Create" "Quit" "..")
  declare -a subMenu
  # SELECT uses PS3 to display the default #?
  # Those are part of the Bash prompt, which will be covered soon.
  export PS3='>>> '
#+END_SRC

#+NAME: Main2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :noweb strip-export :export no
  ###
  # To allow for our enterDirectory function to have a "Up" feature. Our directory stack need to have every part from the root folder.
  # If we don't, the script will be restricted to the current directory and below.
  # This is because the directory stack base entry will be the current directory. Any attempt to popd this entry will not result in the parent directory
  # Note that our current directory will remain at the base of the stack
  currentTree=$(pwd)
  IFS=/
  echo "Clear the directory stack."
  dirs -c
  if [[ $? > 0 ]]; then
      >&2 echo "Error clearing directory stack. Cannot continue."
      exit 1
  fi

  echo -n "Rebuilding it."
  first=0 # our first pushd requires a / in front.
  for part in $currentTree; do
      if [[ $first > 0 ]]; then
          pushd $part > /dev/null
          echo -n '.'
      else
          pushd "/$part" >/dev/null
          echo -n '.'
          first=1
      fi
  done
  echo ""
  unset IFS
  echo $currentTree
  IFS=;
  while true; do
      select OPT in ${mainMenu[@]} *; do
          case $OPT in
              "List")
                  listContent
                  ;;
              "Create")
                  createSub
                  ;;
              "Quit")
                  Quit
                  ;;
              "..")
                  exitDirectory
                  break
                  ;;
              "Reload")
                  break
                  ;;
              ,*)
                  enableSub $OPT
                  if [[ $? == 0 ]]; then
                      break
                  fi
                  ;;
          esac
      done
  done
#+END_SRC

#+NAME:enableSub
#+BEGIN_SRC bash :eval no :tangle no :export no
  function enableSub {
        declare psBAK=$PS3
        declare -a subMenus
        export PS3=$'>>> '

        if [[ -d $1 ]]; then
            subMenus=("Enter" "Delete" "Back")
            select SUB in ${subMenus[@]}; do
                case $SUB in
                    "Enter")
                        enterDirectory $1
                        return 0
                        ;;
                    "Delete")
                        removeDirectory $1
                        break;
                        ;;
                    "Back")
                        $PS3=$psBAK
                        unset subMenus
                        break;
                        ;;
                    ,*)
                        echo "Unknown option."
                        ;;
                esac
            done
        fi

        if [[ -f $1 ]]; then
            subMenus=("Rename" "Delete" "Back")
            select SUB in ${subMenus[@]}; do
                case $SUB in
                    "Rename")
                        $PS3=$psBAK
                        unset subMenus
                        rename $1
                        break;
                        ;;
                    "Delete")
                        $PS3=$psBAK
                        unset subMenus
                        removeFile $1
                        break;
                        ;;
                    "Back")
                        $PS3=$psBAK
                        unset subMenus
                        break
                        ;;
                    ,*)
                        echo "Unknown option: $SUB"
                        ;;
                esac
            done
        fi
    }
#+END_SRC

#+NAME:createSub
#+BEGIN_SRC bash :eval no :tangle no :export no
    function createSub {
        declare psBAK=$PS3
        declare -a subMenus
        export PS3='Create what type? >>> '
        subMenus=("File" "Directory" "Back")
        select SUB in ${subMenus[@]}; do
            case $SUB in
                "File")
                    echo -n "File name: "
                    read f
                    createFile $f
                    unset f
                    export PS3=$psBAK
                    unset subMenus
                    break
                    ;;
                "Directory")
                    echo -n "Directory name: "
                    read n
                    createDirectory $n
                    export PS3=$psBAK
                    unset subMenus
                    break
                    unset n
                    ;;
                "Back")
                    export PS3=$psBAK
                    unset subMenus
                    break;
                    ;;
                ,*)
                    echo "Unknown option $SUB"
                    ;;
            esac
        done

    }
#+END_SRC

#+NAME: rename
#+BEGIN_SRC bash :eval no :tangle no :export no
  function rename {
      if [ -z $1 ]; then
          >&2 echo "Error rename called without arguments."
          return 1
      fi

      declare n
      while true; do
          echo -n "New name: "
          read n
          if [ ! -e $n ]; then
              break;
          fi
      done

      eval "mv -v $1 $n"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 2
      fi
      return 0
  }
#+END_SRC

#+NAME: createFile2
#+BEGIN_SRC bash :eval no :tangle no :export no
  function createFile {
      if [ -z $1 ]; then
          >&2 echo "Error create file called without arguments."
          return 1
      fi

      if [ -e $1 ]; then
          >&2 echo "Error name exists."
          return 2
      fi

      eval "touch $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 3
      fi
      return 0
  }
#+END_SRC

#+NAME: createDirectory2
#+BEGIN_SRC bash :eval no :tangle no :export no
  function createDirectory {
      if [ -z $1 ]; then
          >&2 echo "Error create directory called without arguments."
          return 1
      fi

      if [ -d $1 ]; then
          >&2 echo "Error directory exists."
          return 2
      fi

      eval "mkdir -vp $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 3
      fi
      return 0
  }
#+END_SRC

#+NAME: exitDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function exitDirectory {
      popd >/dev/null # pop the top of the stack
  }

#+END_SRC

#+NAME: enterDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function enterDirectory {
      dir=$1
      if [ -d $dir ]; then
          pushd $dir >/dev/null
          return 0
      fi
      return 1
  }

#+END_SRC

#+NAME: removeDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeDirectory {
      dir=$1
      if [ ! -d $dir ]; then
          ## This should not happen
          return 1
      fi
      ## Check if dir is empty
      cCount=$(ls -A $dir | wc -l)
      if [[ $cCount > 0 ]]; then
          >&2 echo "Error $dir is not empty."
          return 1
      fi
      eval "rmdir -v $dir"
      res=$?
      if [[ $res > 0 ]]; then
          echo "Eval return $res"
          unset res
          return 1
      fi
      return 0
  }
#+END_SRC

#+NAME: removeFile2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeFile {
      if [ -z $1 ]; then
          >&2 echo "Error removeFile called without arguments."
          return 1
      fi

      echo -e "\e[33mWARNING This will really delete the file.\e[0m"
      eval "rm -iv $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval."
          return 2
      fi
      return 0
  }
#+END_SRC

#+NAME: QUIT2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function Quit {
      echo "Cleaning up."
      unset  enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit mainMenu
      PS3=oldPS3
      unset oldPS3
      exit 0
  }
#+END_SRC

