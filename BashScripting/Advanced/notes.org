This file was created in Emacs with org-mode installed.
To have full functionality, please install Emacs with your package manager and see HOW_TO_INSTALL_ORG_MODE
Refer to the video 14 in the following class if needed: https://www.skillshare.com/classes/The-Free-Linux-Bin/1454905790 

:HOW_TO_INSTALL_ORG_MODE:
Pressing TAB on the above line should fold the content, if not ORG is not installed.

  Make sure the following code is present and at the top of your ~/.emacs file
  #+BEGIN_CODE
(package-initialize)
;; load emacs 24's package system. Add MELPA repository.
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   ;; 1 of the 2 next line needs to be there.
   ;;'("melpa" . "http://stable.melpa.org/packages/")
   '("melpa" . "http://melpa.milkbox.net/packages/")
   )
  (add-to-list 'package-archives    '("org" . "https://orgmode.org/elpa") t)
  )

  #+END_CODE

  Restart emacs

  Press M-x package-list-packages
  scroll down to org
  While on that line, press i then press x
  Confirm that you want to install

  Restart Emacs to be sure and the file will look way better.
:END:

:README:
How to operate org files.
Lines starting with 1 or more * are headers, press TAB while on a header, you will cycle its visibility.

src code block are contained within #+BEGIN_SRC and #+END_SRC, pressing TAB on either of those line will cycle its visiblity
You can evaluate the code within emac with the following:
C-c C-c within a code block will evaluate and display the results when possible.

You can export any code with the following:
C-c C-v t export all code block
C-u C-c C-v t export current code block (Where cursor is located)

Code block are export with the filename given in header :tangle. They are exported and are executable ready to use.

To edit a code block press C-' while your cursor is inside or on the header/footer of a src block.
A new buffer will open with the content of the block.
Instruction will be provided on top of new buffer on how to save and exit or cancel and exit.


I strongly recommend that you play with all code block. Modify them, run them, break them.
If you are not comfortable with org mode and prefer to use your text editor, export all code right now, no matter where your cursor is and hack away in comfort.
I also recommend you make copies of the original src block before changing it.
You can copy the whole code block when it is folded by placing the cursor at the begining of the line and press M-w (M = META, usually ALT)
M-w copies the line and press C-y to paste it.
Change the filename value assigned to :tangle and your code will be exported when requested.

Last important rule, when you see a README, Read it!
:END:

A good source of information: https://tldp.org


* Special char
** ?
*** As a test operator
   Within certains expression, the ? indicates a test for a condition.
   In a double-parentheses construct it can serve as a C-style trinary operation
   #+BEGIN_SRC bash :results output :export code :tangle testOperator.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     v0=1
     v1=2
     declare -i v2

     # The following if statement would assign v2 to either 3 or 0.
     # This will cause the sequence to become 1 2 3
     # If you invert v1 & v0, the sequence would be 2 1 0

     #if [[ $v0 < $v1 ]]; then
     #    v2=3
     #else
     #    v2=0
     #fi

     ## This does the same thing
     (( v2 = v0<v1?3:0 ))
     #            ^ ^

     echo $v0 $v1 $v2
   #+END_SRC

   #+RESULTS:

*** Test if variable has been set.
    In a Parameter substitution expression, it can test wheter a variable has been set
    Structure: ${PARAM?ERR_MSG}, ${PARAM:?ERR_MSG}
    If PARAM is set, use it, else print ERR_MSG and abort with exit 1
    Both structure are almost the same, see code for demonstration
    NOTE: Export the next code: C-u C-c C-v t
    #+BEGIN_SRC bash eval:no :export code :tangle testIfVarIsSet.sh :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      var1="hello"
      declare var2

      echo "--------------------"
      echo "Our variables are set:"
      echo -e "\e[32mvar1: \e[0m$var1"
      echo -e "\e[32mvar2\e[0m is declared but not set."
      echo -e "\e[32mvar3\e[0m does not exists except for the test."
      echo "--------------------"

      echo 'This test uses the following format: ${PARAM?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var1?"var1 is not set"}'"\e[0m"
      echo "The test will evaluate to true and the script will continue."
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var1?"var1 is  not set"}
              echo "var1 is set: $var1"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var2?"var2 is not set"}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2?"var2 is  not set"}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo "This test is the same as the previous one, except we do not provide ERR_MSG"
      echo -e "This test code: \e[33m"'${var2?}'"\e[0m"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2?}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM?}'
      echo -e "This test code: \e[33m"'${var3?}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var3?"var3 is  not set"}
              echo "var3 is set: $var3"
              ;;
      esac

      echo
      echo

      echo "--------------------"
      echo 'Now we look at the other format: ${PARAM:?ERR_MSG}'
      echo "The : makes a difference when PARAM has been declared an is null"
      echo "First lets redo our first test with the ':' variation. "
      echo -e "This test code: \e[33m"'${var1:?"var1 is not set"}'"\e[0m"
      echo "The test will evaluate to true and the script will continue."
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var1:?"var1 is  not set"}
              echo "var1 is set: $var1"
              ;;
      esac

      echo "--------------------"
      echo 'This test uses the following format: ${PARAM:?ERR_MSG}'
      echo -e "This test code: \e[33m"'${var2:?"var2 is declared bu not set"}'"\e[0m"
      echo "The test will evaluate to FALSE and the script will exit code 1"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2:?"var2 is declare but not set"}
              echo "var2 is set: $var2"
              ;;
      esac

      echo "--------------------"
      echo "This test is the same as the previous one, except we do not provide ERR_MSG"
      echo -e "This test code: \e[33m"'${var2:?}'"\e[0m"
      echo -n "Do you want to run or skip? R/s: "
      read u
      case $u in
          [sS])
              echo "Skipping...."
              ;;
          [rR]|*) # I could just have given *)
              : ${var2:?}
              echo "var2 is set: $var2"
              ;;
      esac
    #+END_SRC


* Parameter substitution
  Manipulating, expanding variable
  ${PARAM}
  In most case, same as $PARAM, it refers to the value of PARAM. In certain context, only the less ambiguous ${PARAM} works.
  If you seem to have issue with the value of a variable, attempt the parameter substitution ${PARAM}
  It can be used to concatenate strings.
  #+BEGIN_SRC bash :results output :exports code :tangle paramSub.sh :tangle-mode (identity #o0755) :cmdline 2>&1
    #!/bin/bash
    declare myFullString part1 part2
    part1="Hello world, "
    part2="learning python?"
    myFullString=${part1}"Bash is hard, have you considered "${part2}
    echo $myFullString
  #+END_SRC

  #+RESULTS:

  We can use parameter substitution to set a default value.
  ${PARAM-DEFAULT}, ${PARAM:-DEFAULT}
  In the above structure if PARAM is not set, DEFAULT is used.
  #+BEGIN_SRC :results output :exports code
  
  #+END_SRC

* Variable & function

* Conditional statement
** If statement
*** Test Constructs
** Case statement
   We have seen simple case statement in the beginner course.
   Remember the ;;? it is called a terminator.
   Case statement can be more elaborate if we include more terminators

   #+BEGIN_SRC bash :results output :export code :tangle advanceCase.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

   #+END_SRC



* Projects

:README:
You will learn more tricks by looking at my version of the project.
Some missing bash notion can create some challenges doing this project. This is normal, we just started scripting.
For example, select splits the list based on a bash variable IFS. IFS default setting is space.
This cause select for each word in mainMenu. To fix this behavior, we set IFS to ; before our main loop.
Unsetting IFS will reset to its default behavior.
:END:

** Create a simple file manager

Most of the src code below cannot run in evaluation mode without changin src block headers.
To export, place your cursor below #+NAME: scriptExport and press C-u C-c C-v t
Attempting to export on any other code block will not work. This is a setup that allows exportation of the project only without export all code block.
The project will also export when exporting all code block.

#+NAME: scriptExport
#+BEGIN_SRC bash :eval no :tangle myFm.sh :tangle-mode (identity #o0755) :noweb tangle
  #!/bin/bash

  <<scriptHeader>>

  <<exitDirectory>>

  <<enterDirectory>>

  <<listContent>>

  <<createDirectory>>

  <<removeDirectory>>

  <<createFile>>

  <<removeFile>>

  <<QUIT>>

  <<Main>>
#+END_SRC

#+NAME: Main
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :noweb strip-export :export no
  ###
  # To allow for our enterDirectory function to have a "Up" feature. Our directory stack need to have every part from the root folder.
  # If we don't, the script will be restricted to the current directory and below.
  # This is because the directory stack base entry will be the current directory. Any attempt to popd this entry will not result in the parent directory
  # Note that our current directory will remain at the base of the stack
  currentTree=$(pwd)
  IFS=/
  echo "Clear the directory stack."
  dirs -c
  if [[ $? > 0 ]]; then
      >&2 echo "Error clearing directory stack. Cannot continue."
      exit 1
  fi

  echo "Rebuilding it."
  first=0 # our first pushd requires a / in front.
  for part in $currentTree; do
      if [[ $first > 0 ]]; then
          pushd $part
      else
          pushd "/$part"
          first=1
      fi
  done
  unset IFS
  echo $currentTree
  IFS=;
  while true; do
      select OPT in ${mainMenu[@]}; do
          case $OPT in
              "List Content")
                  listContent
                  ;;
              "Create File")
                  createFile
                  ;;
              "Create Directory")
                  createDirectory
                  ;;
              "Remove File")
                  removeFile
                  ;;
              "Remove Directory")
                  removeDirectory
                  ;;
              "Enter Directory")
                  enterDirectory
                  ;;
              "Quit")
                  Quit
                  ;;
              ,*)
                  >&2 echo "Selection not understood."
                  ;;
          esac
      done
  done
#+END_SRC

#+NAME: scriptHeader
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  declare -f enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit
  declare -a mainMenu=("List Content" "Enter Directory" "Create File" "Create Directory" "Remove File" "Remove Directory" "Quit")
#+END_SRC

#+NAME: exitDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function exitDirectory {
      popd >/dev/null # pop the top of the stack
  }

#+END_SRC

#+NAME: enterDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function enterDirectory {
      select DIR in "UP" */ "Back"; do
          case $DIR in
              "UP")
                  popd
                  break;
                  ;;
              "Back")
                  break
                  ;;
              ,*)
                  pushd $DIR
                  break;
                  ;;
          esac
      done
  }

#+END_SRC

#+NAME: listContent
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  # Called without arguments, list the content in current directory
  # Called with an argument, list the content if arg is directory
  # Complains if arg is otherwise.
  function listContent {
      if [ -z $1 ]; then
         ls -l
         return 0
      fi
      if [ -d $1 ]; then
          enterDirectory $1
          ls -l
          exitDirectory
          return 0
      fi
      >&2 echo "Error, listContent argument not understood."
      return 1
  }

#+END_SRC

#+NAME: createDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function createDirectory {
      echo -n "Enter directory name: "
      read n # read user input into var n
      if [ -f $n ]; then # File exists
          >&2 echo "Error file exists."
          return 1
      fi
      eval "mkdir -vp $n" # Attempt to create the directory
      if (( $? > 0 )); then # Return value of eval is stored in $?
          # >&2 redirects output into stderr.
          # It is good practice to redirect error message to stderr (file descriptor 2)
          >&2 echo "eval mkdir -vp $1 returned an error."
          return 1 # Return error
      fi
      echo "Directory $n created."
      return 0 # Success
  }
#+END_SRC

#+NAME: removeDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeDirectory {
      select file in * "QUIT"; do
          if [[ "$file" == "QUIT" ]]; then
              echo "Leaving."
              return 0
          fi
          if [ ! -e $file ]; then
              echo "$file does not exists."
              return 1
          fi
          if [ -f $file ]; then
              echo "$file is a regular file, doing nothing."
              return 2
          fi
          if [ -d $file ]; then
              # Checking if directory is empty
              cCount=eval "ls -A $file | wc -l"
              if [[ $cCount > 0 ]]; then
                  echo "Warning, directory not empty, doing nothing."
                  return 3
              fi
              eval "rmdir -iv $file"
              if [[ $? > 0 ]]; then
                  echo "Error with eval comand to remove directory."
                  return 4
              fi
              return 0
          fi
          >&2 echo "Unknown error, but file was not deleted."
          return 127
      done
  }
#+END_SRC

#+NAME: createFile
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function createFile {
      echo -n "Enter file name: "
      read n # read user input into var n
      if [ -e $n ]; then # File exists
          >&2 echo "Error file exists."
          return 1
      fi
      eval "touch $n" # Attempt to create the directory
      if (( $? > 0 )); then # Return value of eval is stored in $?
          # >&2 redirects output into stderr.
          # It is good practice to redirect error message to stderr (file descriptor 2)
          >&2 echo "eval touch -vp $1 returned an error."
          return 1 # Return error
      fi
      echo "File $n created."
      return 0 # Success
  }
#+END_SRC

#+NAME: removeFile
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeFile {
      select file in * "QUIT"; do
          if [[ "$file" == "QUIT" ]]; then
              echo "Leaving."
              return 0
          fi
          if [ ! -e $file ]; then
              echo "$file does not exists."
              return 1
          fi
          if [ -d $file ]; then
              echo "$file is a directory file, doing nothing."
              return 2
          fi
          if [ -f $file ]; then
              echo -e "\e[33mWARNING, THIS WILL REALLY DELETE THE FILE\e[0m"
              eval "rm -iv $file"
              if [[ $? > 0 ]]; then
                  echo "eval returned and error."
                  return 3
              fi
              echo "File deleted."
              return 0
          fi
          >&2 echo "Unknown error, but file was not deleted."
          return 3
      done
  }
#+END_SRC

#+NAME: QUIT
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function Quit {
      echo "Cleaning up."
      unset  enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit mainMenu
      exit 0
  }
#+END_SRC





** Here is another version, making more use of the select builtin

Most of the src code below cannot run in evaluation mode without changin src block headers.
To export, place your cursor below #+NAME: scriptExport and press C-u C-c C-v t
Attempting to export on any other code block will not work. This is a setup that allows exportation of the project only without export all code block.
The project will also export when exporting all code block.

#+NAME: scriptExport2
#+BEGIN_SRC bash :eval no :tangle myFm2.sh :tangle-mode (identity #o0755) :noweb tangle
  #!/bin/bash

  <<scriptHeader2>>

  <<exitDirectory2>>

  <<enterDirectory2>>

  <<listContent2>>

  <<createDirectory2>>

  <<createFile2>>

  <<rename>>

  <<removeDirectory2>>

  <<removeFile2>>

  <<enableSub>>
  
  <<createSub>>

  <<QUIT2>>

  <<Main2>>
#+END_SRC

#+NAME: scriptHeader2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  declare -f enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit
  ## Simple hack to display colored item in select.
  declare -a mainMenu=("Reload" "Create" "Quit" "..")
  declare -a subMenu
  # SELECT uses PS3 to display the default #?
  # Those are part of the Bash prompt, which will be covered soon.
  export PS3='>>> '
#+END_SRC

#+NAME: Main2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :noweb strip-export :export no
  ###
  # To allow for our enterDirectory function to have a "Up" feature. Our directory stack need to have every part from the root folder.
  # If we don't, the script will be restricted to the current directory and below.
  # This is because the directory stack base entry will be the current directory. Any attempt to popd this entry will not result in the parent directory
  # Note that our current directory will remain at the base of the stack
  currentTree=$(pwd)
  IFS=/
  echo "Clear the directory stack."
  dirs -c
  if [[ $? > 0 ]]; then
      >&2 echo "Error clearing directory stack. Cannot continue."
      exit 1
  fi

  echo -n "Rebuilding it."
  first=0 # our first pushd requires a / in front.
  for part in $currentTree; do
      if [[ $first > 0 ]]; then
          pushd $part > /dev/null
          echo -n '.'
      else
          pushd "/$part" >/dev/null
          echo -n '.'
          first=1
      fi
  done
  echo ""
  unset IFS
  echo $currentTree
  IFS=;
  while true; do
      select OPT in ${mainMenu[@]} *; do
          case $OPT in
              "List")
                  listContent
                  ;;
              "Create")
                  createSub
                  ;;
              "Quit")
                  Quit
                  ;;
              "..")
                  exitDirectory
                  break
                  ;;
              "Reload")
                  break
                  ;;
              ,*)
                  enableSub $OPT
                  if [[ $? == 0 ]]; then
                      break
                  fi
                  ;;
          esac
      done
  done
#+END_SRC

#+NAME:enableSub
#+BEGIN_SRC bash :eval no :tangle no :export no
  function enableSub {
        declare psBAK=$PS3
        declare -a subMenus
        export PS3=$'>>> '

        if [[ -d $1 ]]; then
            subMenus=("Enter" "Delete" "Back")
            select SUB in ${subMenus[@]}; do
                case $SUB in
                    "Enter")
                        enterDirectory $1
                        return 0
                        ;;
                    "Delete")
                        removeDirectory $1
                        break;
                        ;;
                    "Back")
                        $PS3=$psBAK
                        unset subMenus
                        break;
                        ;;
                    ,*)
                        echo "Unknown option."
                        ;;
                esac
            done
        fi

        if [[ -f $1 ]]; then
            subMenus=("Rename" "Delete" "Back")
            select SUB in ${subMenus[@]}; do
                case $SUB in
                    "Rename")
                        $PS3=$psBAK
                        unset subMenus
                        rename $1
                        break;
                        ;;
                    "Delete")
                        $PS3=$psBAK
                        unset subMenus
                        removeFile $1
                        break;
                        ;;
                    "Back")
                        $PS3=$psBAK
                        unset subMenus
                        break
                        ;;
                    ,*)
                        echo "Unknown option: $SUB"
                        ;;
                esac
            done
        fi
    }
#+END_SRC

#+NAME:createSub
#+BEGIN_SRC bash :eval no :tangle no :export no
    function createSub {
        declare psBAK=$PS3
        declare -a subMenus
        export PS3='Create what type? >>> '
        subMenus=("File" "Directory" "Back")
        select SUB in ${subMenus[@]}; do
            case $SUB in
                "File")
                    echo -n "File name: "
                    read f
                    createFile $f
                    unset f
                    export PS3=$psBAK
                    unset subMenus
                    break
                    ;;
                "Directory")
                    echo -n "Directory name: "
                    read n
                    createDirectory $n
                    export PS3=$psBAK
                    unset subMenus
                    break
                    unset n
                    ;;
                "Back")
                    export PS3=$psBAK
                    unset subMenus
                    break;
                    ;;
                ,*)
                    echo "Unknown option $SUB"
                    ;;
            esac
        done

    }
#+END_SRC

#+NAME: rename
#+BEGIN_SRC bash :eval no :tangle no :export no
  function rename {
      if [ -z $1 ]; then
          >&2 echo "Error rename called without arguments."
          return 1
      fi

      declare n
      while true; do
          echo -n "New name: "
          read n
          if [ ! -e $n ]; then
              break;
          fi
      done

      eval "mv -v $1 $n"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 2
      fi
      return 0
  }
#+END_SRC

#+NAME: createFile2
#+BEGIN_SRC bash :eval no :tangle no :export no
  function createFile {
      if [ -z $1 ]; then
          >&2 echo "Error create file called without arguments."
          return 1
      fi

      if [ -e $1 ]; then
          >&2 echo "Error name exists."
          return 2
      fi

      eval "touch $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 3
      fi
      return 0
  }
#+END_SRC

#+NAME: createDirectory2
#+BEGIN_SRC bash :eval no :tangle no :export no
  function createDirectory {
      if [ -z $1 ]; then
          >&2 echo "Error create directory called without arguments."
          return 1
      fi

      if [ -d $1 ]; then
          >&2 echo "Error directory exists."
          return 2
      fi

      eval "mkdir -vp $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 3
      fi
      return 0
  }
#+END_SRC

#+NAME: exitDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function exitDirectory {
      popd >/dev/null # pop the top of the stack
  }

#+END_SRC

#+NAME: enterDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function enterDirectory {
      dir=$1
      if [ -d $dir ]; then
          pushd $dir >/dev/null
          return 0
      fi
      return 1
  }

#+END_SRC

#+NAME: removeDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeDirectory {
      dir=$1
      if [ ! -d $dir ]; then
          ## This should not happen
          return 1
      fi
      ## Check if dir is empty
      cCount=$(ls -A $dir | wc -l)
      if [[ $cCount > 0 ]]; then
          >&2 echo "Error $dir is not empty."
          return 1
      fi
      eval "rmdir -v $dir"
      res=$?
      if [[ $res > 0 ]]; then
          echo "Eval return $res"
          unset res
          return 1
      fi
      return 0
  }
#+END_SRC

#+NAME: removeFile2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeFile {
      if [ -z $1 ]; then
          >&2 echo "Error removeFile called without arguments."
          return 1
      fi

      echo -e "\e[33mWARNING This will really delete the file.\e[0m"
      eval "rm -iv $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval."
          return 2
      fi
      return 0
  }
#+END_SRC

#+NAME: QUIT2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function Quit {
      echo "Cleaning up."
      unset  enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit mainMenu
      PS3=oldPS3
      unset oldPS3
      exit 0
  }
#+END_SRC

