This file was created in Emacs with org-mode installed.
To have full functionality, please install Emacs with your package manager and see HOW_TO_INSTALL_ORG_MODE
Refer to the video 14 in the following class if needed: https://www.skillshare.com/classes/The-Free-Linux-Bin/1454905790 

:HOW_TO_INSTALL_ORG_MODE:
Pressing TAB on the above line should fold the content, if not ORG is not installed.

  Make sure the following code is present and at the top of your ~/.emacs file
  #+BEGIN_CODE
(package-initialize)
;; load emacs 24's package system. Add MELPA repository.
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   ;; 1 of the 2 next line needs to be there.
   ;;'("melpa" . "http://stable.melpa.org/packages/")
   '("melpa" . "http://melpa.milkbox.net/packages/")
   )
  (add-to-list 'package-archives    '("org" . "https://orgmode.org/elpa") t)
  )

  #+END_CODE

  Restart emacs

  Press M-x package-list-packages
  scroll down to org
  While on that line, press i then press x
  Confirm that you want to install

  Restart Emacs to be sure and the file will look way better.
:END:

:README:
How to operate org files.
Lines starting with 1 or more * are headers, press TAB while on a header, you will cycle its visibility.

src code block are contained within #+BEGIN_SRC and #+END_SRC, pressing TAB on either of those line will cycle its visiblity
You can evaluate the code within emac with the following:
C-c C-c within a code block will evaluate and display the results when possible.

You can export any code with the following:
C-c C-v t export all code block
C-u C-c C-v t export current code block (Where cursor is located)

Code block are export with the filename given in header :tangle. They are exported and are executable ready to use.

To edit a code block press C-' while your cursor is inside or on the header/footer of a src block.
A new buffer will open with the content of the block.
Instruction will be provided on top of new buffer on how to save and exit or cancel and exit.


I strongly recommend that you play with all code block. Modify them, run them, break them.
If you are not comfortable with org mode and prefer to use your text editor, export all code right now, no matter where your cursor is and hack away in comfort.
I also recommend you make copies of the original src block before changing it.
You can copy the whole code block when it is folded by placing the cursor at the begining of the line and press M-w (M = META, usually ALT)
M-w copies the line and press C-y to paste it.
Change the filename value assigned to :tangle and your code will be exported when requested.

Last important rule, when you see a README, Read it!
:END:

Bash for beginner reference: http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html


* Special char
  http://tldp.org/LDP/abs/html/special-chars.html
** Comments #
***  A line beginning with # is a comment
    #+BEGIN_SRC sh

      # this is a comment, this script does nothing!

    #+END_SRC
***  Comments can follow the end of a command
    #+BEGIN_SRC sh
       echo "There is a comment at the end of this line" # This is my comment
       #                                                ^ Note whitespace before

    #+END_SRC
***  Comment can also be embedded within a pipe
    #+BEGIN_SRC bash
      cat /var/log/syslog | grep "systemd" |
          # this is a comment embeded within a pipe
          wc -l
    #+END_SRC

    #+RESULTS:
    : 61

** Command separator ;
   Allows for more the 1 command on the same line.
   #+BEGIN_SRC bash
     echo "hello"; echo "there."
   #+END_SRC

   #+RESULTS:
   | hello  |
   | there. |

** Quoting double quote VS single quote

   Double quote Preserves (from interpretation) most special characters
   Single quote preseves all special characters

   In this example, we demonstrate the difference between no quotes and "" with the ls command.
   #+BEGIN_SRC bash :results output :exports code :tangle declareFunc.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash
     # In this example, sy* will be expanded and display all file starting with sy
     ls -l /var/log/sy*

     # In this case, we are looking for a file named sy*
     ls -l "/var/log/sy*"
   #+END_SRC

   #+RESULTS:
   : -rw-r----- 1 syslog adm 138535 Dec 13 14:34 /var/log/syslog
   : -rw-r----- 1 syslog adm 165700 Dec 13 00:07 /var/log/syslog.1
   : -rw-r----- 1 syslog adm  10253 Dec 12 00:06 /var/log/syslog.2.gz
   : -rw-r----- 1 syslog adm  44537 Dec 11 00:06 /var/log/syslog.3.gz
   : -rw-r----- 1 syslog adm   4109 Dec 10 00:08 /var/log/syslog.4.gz
   : -rw-r----- 1 syslog adm   3860 Dec  9 00:07 /var/log/syslog.5.gz
   : -rw-r----- 1 syslog adm   6842 Dec  8 00:05 /var/log/syslog.6.gz
   : -rw-r----- 1 syslog adm   7931 Dec  7 00:08 /var/log/syslog.7.gz
   : ls: cannot access '/var/log/sy*': No such file or directory

   Here we demonstrate we demonstrate the difference between "" and '' with the ls command.
   #+BEGIN_SRC bash :shebang :results output :exports code :tangle declareFunc.sh :tangle-mode (identity #o0755)
     var="hello"
     echo $var
     echo "$var"
     echo '$var'


   #+END_SRC
   
   #+RESULTS:
   : hello
   : hello
   : $var


* Variable & function
   Bash variable are untype. Basically all variable are char strings. But when it contains only digit, bash allow arithmetic operation.
   Example:
   :README:
   To edit a code block press C-' while your cursor is inside or on the header/footer of a src block.
   A new buffer will open with the content of the block.
   Instruction will be provided on top of new buffer on how to save and exit or cancel and exit.
   :END:
   #+BEGIN_SRC bash :results output :exports code :tangle var.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     declare a # Good habit but not required.

     a="hello" # a is a string
     # b is a int but under the hood, this is just a char which bash will allow arithmetic operation on it.
     b=2
     echo $a
     echo $b

     ## Because it all is a char string, this is possible
     ## now a can have arithmetic operation and not b
     a=4
     b="bye!"
     echo $a
     echo $b

     # Arithmetic operation needs to be contained within (( ))
     # c does not have to exists before now.
     ((c=$a+2))
     echo $c

     # b is a string, Bash will complain
     ((d=$b+3))
     echo $d
   #+END_SRC

   #+RESULTS:
   : hello
   : 2
   : 4
   : bye!
   : 6
   : /tmp/babel-16833Kcr/sh-script-16833Q9K: line 25: ((: d=bye!+3: syntax error in expression (error token is "!+3")
   : 0
 
** Functions
   Declaring function and passing parameters
   Functions are declare with the function keyword. Example: function myFunc1
   After the function name, a space is required.
   Then you can proceed with opening the function's scope: function myFunc1 { ... }
   You are allowed to place () between function name and { ... } like so: function myFunc1 () { ... }
   But nothing is allowed inside ()
   #+BEGIN_SRC bash :results output :export code :tangle func.sh :tangle-mode (identity #o0755)
     #!/bin/bash

     function myFunction { # note the space
         #              ^ myFunction{ will cause an error
         echo "Hello you have called myFunction"

         ## Function parameters are not declared
         if [ -z "$1" ]; then #is param 1 zero length?
             echo "You have not given me a paramter."
         else
             echo "I got $1."
         fi
     }

     # Function can also be declared like this:
     # But no arguments within ()
     function myFunc () {
         echo "Hello you have called myFunc"

         ## Function parameters are not declared
         if [ -z "$1" ]; then #is param 1 zero length?
             echo "You have not given me a paramter."
         else
             echo "I got $1."
         fi
     }

     ## Calling functions
     myFunction
     myFunction "Hello"
     myFunc
     myFunc "Hello"
   #+END_SRC

   #+RESULTS:
   : Hello you have called myFunction
   : You have not given me a paramter.
   : Hello you have called myFunction
   : I got Hello.
   : Hello you have called myFunc
   : You have not given me a paramter.
   : Hello you have called myFunc
   : I got Hello.


   Functions can return integer only. Attempt to return otherwise results in error.
   #+BEGIN_SRC bash :results output :export code :tangle funcReturn.sh :tangle-mode (identity #o0755)
     #!/bin/bash

     function myFunction { # note the space
         #              ^ myFunction{ will cause an error
         echo "Hello you have called myFunction"

         ## Function parameters are not declared
         if [ -z "$1" ]; then #is param 1 zero length?
             echo "Error, you have not given me a paramter."
             return 1
         else
             echo "I got $1."
             return 0
         fi
     }

     # Function can also be declared like this:
     function myFunc () {
         echo "Hello you have called myFunc"

         ## Function parameters are not declared
         if [ -z "$1" ]; then #is param 1 zero length?
             echo "Error: you have not given me a paramter."
             return 1
         else
             echo "I got $1."
             return 0
         fi
     }

     function checkRetVal {
         if [[ "$1" > 0 ]]; then
             # Usualy a value of 0 = success >0=error.
             echo "Error, function returned 1."
         else
             echo "Success, function returned 0."
         fi
     }
     ## Calling functions
     myFunction

     # Return value is stored in $?
     # Check the return value of last ran command, in this case value return by functions.
     checkRetVal $?

     myFunction "Hello"
     checkRetVal $?

     myFunc
     checkRetVal $?

     myFunc "Hello"
     checkRetVal $?
   #+END_SRC

   #+RESULTS:
   #+begin_example
   Hello you have called myFunction
   Error, you have not given me a paramter.
   Error, function returned 1.
   Hello you have called myFunction
   I got Hello.
   Success, function returned 0.
   Hello you have called myFunc
   Error: you have not given me a paramter.
   Error, function returned 1.
   Hello you have called myFunc
   I got Hello.
   Success, function returned 0.
   #+end_example

   So what if I need to return a string.
   In a sense you can pass a variable by reference and modify that variable inside a function.
   #+BEGIN_SRC bash :results output :export code :tangle funcRefVar.sh :tangle-mode (identity #o0755)
     #!/bin/bash

     declare var
     function refVar {
         eval "$1='Hello world'" # $var now = Hellow World
     }
     var="hello"
     echo $var
     refVar var # Notive I do not pass $var, just var.
     echo $var
   #+END_SRC

   #+RESULTS:
   : hello
   : Hello world

   Functions cannot be empty
   #+BEGIN_SRC bash :results output :export code :tangle emptyFunc.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     ## This will prevent execution
     function func1 { 
    
     }

     ## Function with comment only are still empty
     function func2 {
         # My comment
         ## Even multiple line
         ### This will blowup.
     }


     # Need to create an empty function?
     # The closest you could come to it is this:
     function iLookEmpty {
         echo 1 > /dev/null
     }
   #+END_SRC

   #+RESULTS:

** Declare or typeset
   http://tldp.org/LDP/abs/html/declareref.html

   Declare or typeset both exact same.
   Declare is specific to version 2 of bash.
   Typeset work on ksh

*** Options & examples

**** -r readonly
     Rough equivalent to C const type.
     Attempt to change the value results in error.
     Notice the :cmdline 2>&1. This redirect stderr into stdout and is considered normal output by org.
     This results in error message being displayed in the results section.
     #+BEGIN_SRC bash :results output :exports code :tangle roVar.sh :tangle-mode (identity #o0755) :cmdline 2>&1
       #!/bin/bash
       declare -r roVar=2
       echo "roVar: $roVar"
       roVar=4 # Illegal attempt to change roVar
       echo "roVar: $roVar"

     #+END_SRC
     #+RESULTS:
     : roVar: 2
     : /tmp/babel-16833Kcr/sh-script-16833d5o: line 5: roVar: readonly variable
     : roVar: 2

**** -i integer
     Declare variable as integer, attempt to assign a string can result in error

     #+BEGIN_SRC bash :results output :exports code :tangle intVar.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash
     declare -i myInt
     myInt=2
     echo $myInt
     myInt="I am a string." # Bash will complain, myInt=2. Same behavior with single quote.
     echo $myInt
     myInt="Hello" # Bash does not complain, myInt=0. Same behavior with single quote.
     echo $myInt
     #+END_SRC

     #+RESULTS:
     : 2
     : /tmp/babel-16833Kcr/sh-script-168333N1: line 6: I am a string.: syntax error: invalid arithmetic operator (error token is ".")
     : 2
     : 0

**** -a array
     Declare an array
     #+BEGIN_SRC bash :results output :exports code :tangle arr.sh :tangle-mode (identity #o0755)
       #!/bin/bash
       declare -a myArray
       myArray=(1 2 3 4 5) # This is an array

       ## One way to loop through an array
       for m in ${myArray[@]}; do
           echo $m
       done

       ## Here is another.
       x=0
       arrLen=${#myArray[@]} # This is how you get the length of an array

       ## Note the double  [[]]
       while [[ $x < $arrLen ]]; do
           ###
           # Mathematical operation in Bash scripting needs (())
           # sum=((3+4))
           ###
           val=${myArray[$x]} ## This is how you refer to a item in the array
           sum=$(($val + 10))
           echo "Sum: $sum"
           ((x++))
       done

     #+END_SRC

     #+RESULTS:
     #+begin_example
     1
     2
     3
     4
     5
     Sum: 11
     Sum: 12
     Sum: 13
     Sum: 14
     Sum: 15
     #+end_example

**** -f function
     declare -f without arguments does a listing of all function previously defined in that script.
     #+BEGIN_SRC bash :results output :exports code :tangle declareFunc.sh :tangle-mode (identity #o0755)
       #!/bin/bash

       declare -f myFunc2
       declare myFunc3 # This works too.

       # Function do not need to be declared first.
       function myFunc1 { # Note the space ..nc1 {
           echo "You have called myFunc1"
       }



       function myFunc2 {
           echo "You have called myFunc2"
       }

       function myFunc3 {
           echo "You have called myFunc3"
       }



       # There is no main function in bash, this is it.
       myFunc1
       myFunc2
       myFunc3
       declare -f
     #+END_SRC

     #+RESULTS:
     #+begin_example
     You have called myFunc1
     You have called myFunc2
     You have called myFunc3
     myFunc1 () 
     { 
         echo "You have called myFunc1"
     }
     myFunc2 () 
     { 
         echo "You have called myFunc2"
     }
     myFunc3 () 
     { 
         echo "You have called myFunc3"
     }
     #+end_example

**** -x export
     - Note taken on [2018-12-11 Tue 11:10] \\
       This will be easier to explain when we have a better understanding of bash environment and export, it will be covered in a later class.

     Declare a var as available for exporting outside the env of the script

**** by itself
     When called without argument, declare will list the previously declared functions.
     #+BEGIN_SRC bash :results output :exports code :tangle declareNoArg.sh :tangle-mode (identity #o0755)
     #!/bin/bash

     declare -f myFunc2
     declare myFunc3 # This works too.

     # Function do not need to be declared first.
     function myFunc1 { # Note the space ..nc1 {
         echo "You have called myFunc1"
     }



     function myFunc2 {
         echo "You have called myFunc2"
     }

     function myFunc3 {
         echo "You have called myFunc3"
     }



     # There is no main in bash, this is it.
     myFunc1
     myFunc2
     myFunc3
     declare -f
     #+END_SRC


* Conditional statement
** If statement
   http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html
*** Structure
    #+BEGIN_SRC bash  bash :results output :exports none
      ## Space are important

      if ...; then ... ; fi # One line


      if ..; then # Bracket are not always required, but a good habit.
          ...
      fi

      if [ ... ]; then # Single bracket mode
          ...
      fi

      if [[ ... ]]; then # Double brackets, will be explained further.
          ...
      fi

      ## Else

      if ... ; then
          ...
      else
          ...
      fi

      ## Else if

      if ... ; then
          ..
      elif ... ; then
          ...
      elif ... ; then
          ...
      else
          ...
      fi


    #+END_SRC
**** [] VS [[]]
     Source: http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_02.html
     Contrary to [, [[ prevents word splitting of variable values. So, if VAR="var with spaces", you do not need to double quote $VAR in a test - eventhough using quotes remains a good habit. 
     Also, [[ prevents pathname expansion, so literal strings with wildcards do not try to expand to filenames. 
     Using [[, == and != interpret strings to the right as shell glob patterns to be matched against the value to the left, for instance: [[ "value" == val* ]].
     #+BEGIN_SRC bash :results output :exports code :tangle singleDoubleBrackets.sh :tangle-mode (identity #o0755)
       #!/bin/bash

       var1="Hello worlds!"
       var2="Hello worlds!"


       echo '$var1=>'$var1
       echo '$var2=>'$var2

       echo -n 'Test: [ "$var1" = "$var2" ] => ' # echo -n does not return at the end, leaving the cursor in place
       if [ "$var1" = "$var2" ] ; then
           echo "var1 and var2 are equals"
       else
           echo "var1 and var2 are NOT equals"
       fi

       echo -n 'Test: [ $var1 = $var2 ] => '
       if [ $var1 = $var2 ]; then
           echo "var1 and var2 are equals"
       else
           echo "var1 and var2 are NOT equals"
       fi

       echo -n 'Test: [[ "$var1" = "$var2" ]] => '
       if [[ "$var1" = "$var2" ]]; then
           echo "var1 and var2 are equals"
       else
           echo "var1 and var2 are NOT equals"
       fi

       echo -n 'Test: [[ $var1 = $var2 ]] => '
       if [[ $var1 = $var2 ]]; then
           echo "var1 and var2 are equals"
       else
           echo "var1 and var2 are NOT equals"
       fi

       echo -n 'Test: [ "$var1" == "$var2" ] => '
       if [ "$var1" == "$var2" ]; then
           echo "var1 and var2 are equals"
       else
           echo "var1 and var2 are NOT equals"
       fi

       echo -n 'Test: [ $var1 == $var2 ] => '
       if [ $var1 == $var2 ]; then
           echo "var1 and var2 are equals"
       else
           echo "var1 and var2 are NOT equals"
       fi

       echo -n 'Test: [[ "$var1" == "$var2" ]] => '
       if [[ "$var1" == "$var2" ]]; then
           echo "var1 and var2 are equals"
       else
           echo "var1 and var2 are NOT equals"
       fi

       echo -n 'Test: [[ $var1 == $var2 ]] => '
       if [[ $var1 == $var2 ]]; then
           echo "var1 and var2 are equals"
       else
           echo "var1 and var2 are NOT equals"
       fi
     #+END_SRC

     #+RESULTS:
     #+begin_example
     $var1=>Hello worlds!
     $var2=>Hello worlds!
     Test: [ "$var1" = "$var2" ] => var1 and var2 are equals
     Test: [ $var1 = $var2 ] => var1 and var2 are NOT equals
     Test: [[ "$var1" = "$var2" ]] => var1 and var2 are equals
     Test: [[ $var1 = $var2 ]] => var1 and var2 are equals
     Test: [ "$var1" == "$var2" ] => var1 and var2 are equals
     Test: [ $var1 == $var2 ] => var1 and var2 are NOT equals
     Test: [[ "$var1" == "$var2" ]] => var1 and var2 are equals
     Test: [[ $var1 == $var2 ]] => var1 and var2 are equals
     #+end_example

*** Test on files
    For a full list, refer to link above. But here are a few test related to files that can be done with the if statement.
    #+BEGIN_SRC  bash :results output :exports code :tangle ifFileTest.sh :tangle-mode (identity #o0755)
      #!/bin/bash

      # Test if file exits
      file=/var/log/syslog
      if [ -a $file ]; then # Note the space [ ... ]
          echo "$file exists."
      else
          echo "$file does not exists."
      fi

      # Negative test
      file=/var/log/sysll # This file does not exists
      if [ ! -a $file ]; then
          echo "$file does not exists."
      elif [ -a $file ]; then
          echo "$file does exists."
      fi

      file=/var/log/syslog

      if [ -f $file ]; then # True if file exists AND is a regular file
          echo "$file is a regular file"
      fi

      if [ ! -d $file ]; then # True if file exists AND is a directory
          echo "$file is NOT a directory"
      fi
    #+END_SRC


    #+RESULTS:
    : /var/log/syslog exists.
    : /var/log/sysll does not exists.
    : /var/log/syslog is a regular file
    : /var/log/syslog is NOT a directory

*** Comparison
    Source: https://www.tldp.org/LDP/abs/html/comparison-ops.html

**** Bash specific operators
     Here we look at bash specific operator, instead of >, we use -gt
     Interger comparison with single bracket 
     #+BEGIN_SRC bash :results output :exports code :tangle ifComparison.sh :tangle-mode (identity #o0755) :cmdline 2>&1
       #!/bin/bash

       # Integer comparison
       a=1
       b=1
       c=2

       echo '$a => '$a
       echo '$b => '$b
       echo '$c => '$c

       if [ $a -eq $b ]; then
           echo '[ $a -eq $b ] => TRUE'
       else
           echo '[ $a -eq $b ] => FALSE'
       fi

       if [ "$a" -ne "$b" ]; then
           echo '[ "$a" -ne "$b" ] => TRUE'
       else
           echo '[ "$a" -ne "$b" ] => FALSE'
       fi

       if [ $a -gt $c ]; then
           echo '[ $a -gt $c ] => TRUE'
       else
           echo '[ $a -gt $c ] => TRUE'
       fi

       if [ "$a" -ge "$b" ]; then
           echo '[ "$a" -ge "$b" ] => TRUE'
       else
           echo '[ "$a" -ge "$b" ] => FALSE'
       fi

       if [ $c -lt $b ]; then
           echo '[ $c -lt $b ] => TRUE'
       else
           echo '[ $c -lt $b ] => FALSE'
       fi

       if [ "$a" -le "$c" ]; then
           echo '[ "$a" -le "$c" ] => TRUE'
       else
           echo '[ "$a" -le "$c" ] => FALSE'
       fi

       a="hello"
       b="hello"

       # Those comparison operator are for integers.
       if [ $a -eq $b ]; then
           echo '$a = $b'
       else
           echo '$a != $b'
       fi
    #+END_SRC

     #+RESULTS:

     Interger comparison with double bracket
     :SPOILER:
    Works the same.
    :END:
     #+BEGIN_SRC bash :results output :exports code :tangle intComparison.sh :tangle-mode (identity #o0755) :cmdline 2>&1
       #!/bin/bash

       # Integer comparison
       a=1
       b=1
       c=2
       if [[ $a -eq $b ]]; then
           echo '$a = $b'
       else
           echo '$a != $b'
       fi

       if [[ "$a" -ne "$b" ]]; then
           echo '$a != $b'
       else
           echo '$a = $b'
       fi

       if [[ $a -gt $c ]]; then
           echo '$a > $c'
       else
           echo '$a < $c'
       fi

       if [[ "$a" -ge "$b" ]]; then
           echo '$a >= $b'
       else
           echo '$a <= $b'
       fi

       if [[ $c -lt $b ]]; then
           echo '$c < $b'
       else
           echo '$c > $b'
       fi

       if [[ "$a" -le "$c" ]]; then
           echo '$a <= $b'
       else
           echo '$a >= $b'
       fi

       a="hello"
       b="hello1"

       # Do not use these operator for string comparison
       if [[ $a -eq $b ]]; then
           echo '$a = $b'
       else
           echo '$a != $b'
       fi
    #+END_SRC

**** More common way to test
     With more commons way to test, come more way to get confused.
     We will look at the difference between if [ ... ], if [[]], if (( ... ))
     The results of the following 3 script can be a little confusing. What is important to notice and remember:
     - single bracket [ ] works good to check if integers are = or == or != or ! .. = ..
       Point being, single bracket is good for equals or not.
     - Single brackets are not reliable to say the least when comparing > <, Binarie operator worked fine in single brackets.


     Interger comparison with single bracket
     #+BEGIN_SRC bash :results output scalar :exports code :tangle ifComparison.sh :tangle-mode (identity #o0755) :cmdline 2>&1
       #!/bin/bash

       # Integer comparison
       a=1
       b=1
       c=2
       echo -n 'Current test: [ $a = $b ]... : '
       if [ $a = $b ]; then
           echo '$a = $b <= RIGHT!' 
       else
           echo '$a != $b <= WRONG!'
       fi

       echo -n 'Current test: [ $a == $b ]... : '
       if [ $a == $b ]; then
           echo '$a = $b <= RIGHT!'
       else
           echo '$a != $b <= WRONG!'
       fi

       echo -n 'Current test: [ "$a" != "$b" ]... : '
       if [ "$a" != "$b" ]; then
           echo '$a != $b <= WRONG!'
       else
           echo '$a = $b <= RIGHT!'
       fi

       echo -n 'Current test: [ ! "$a" = "$b" ]... : '
       if [ ! "$a" = "$b" ]; then
           echo '! $a = $b <= WRONG!'
       else
           echo '$a = $b <= RIGHT!'
       fi

       echo -n 'Current test: [ $a > $c ]... : '
       if [ $a > $c ]; then
           echo '$a > $c <= WRONG!'
       else
           echo '$a < $c <= RIGHT!'
       fi

       echo -n 'Current test: [ $c < $b ]... : '
       if [ $c < $b ]; then
           echo '$c < $b <= WRONG!'
       else
           echo '$c > $b <= RIGHT!'
       fi

       echo -n 'Current test: [ "$a" > "$c" ]... : '
       if [ "$a" > "$c" ]; then
           echo '$a > $c <= WRONG!'
       else
           echo '$a < $c <= RIGHT!'
       fi

       echo -n 'Current test: [ "$c" < "$b" ]... : '
       if [ "$c" < "$b" ]; then
           echo '$c < $b <= WRONG!'
       else
           echo '$c > $b <= RIGHT'
       fi

       ## Take note of the ones below.

       if [ "$a" >= "$b" ]; then
           echo '$a >= $b <= RIGHT!'
       else
           echo '$a <= $b <= WRONG!'
       fi

       if [ "$a" <= "$c" ]; then
           echo '$a <= $b <= RIGHT!'
       else
           echo '$a >= $b <= WRONG!'
       fi
    #+END_SRC
    
     #+RESULTS:
     #+begin_example
     Current test: [ $a = $b ]... : $a = $b <= RIGHT!
     Current test: [ $a == $b ]... : $a = $b <= RIGHT!
     Current test: [ "$a" != "$b" ]... : $a = $b <= RIGHT!
     Current test: [ ! "$a" = "$b" ]... : $a = $b <= RIGHT!
     Current test: [ $a > $c ]... : $a > $c <= WRONG!
     Current test: [ $c < $b ]... : /tmp/babel-16833Kcr/sh-script-16833S4k: line 44: 1: No such file or directory
     $c > $b <= RIGHT!
     Current test: [ "$a" > "$c" ]... : $a > $c <= WRONG!
     Current test: [ "$c" < "$b" ]... : /tmp/babel-16833Kcr/sh-script-16833S4k: line 58: 1: No such file or directory
     $c > $b <= RIGHT
     /tmp/babel-16833Kcr/sh-script-16833S4k: line 66: [: 1: unary operator expected
     $a <= $b <= WRONG!
     /tmp/babel-16833Kcr/sh-script-16833S4k: line 72: [: 1: unary operator expected
     $a >= $b <= WRONG!
     #+end_example

     Interger comparison with double bracket
     #+BEGIN_SRC bash :results output :exports code :tangle intComparison.sh :tangle-mode (identity #o0755) :cmdline 2>&1
       #!/bin/bash

       # Integer comparison
       a=1
       b=1
       c=2

       echo -n 'Current test: [[ $a = $b ]] '
       if [[ $a = $b ]]; then
           echo '$a = $b <= RIGHT!'
       else
           echo '$a != $b <= WRONG!'
       fi

       echo -n 'Current test: [[ $a == $b ]] '
       if [[ $a == $b ]]; then
           echo '$a == $b <= RIGHT!'
       else
           echo '$a != $b <= WRONG!'
       fi

       echo -n 'Current test: [[ "$a" != "$b" ]] '
       if [[ "$a" != "$b" ]]; then
           echo '$a != $b <= WRONG!'
       else
           echo '$a = $b <+ RIGHT!'
       fi
       echo -n 'Current test: [[ ! "$a" = "$b" ]] '
       if [[ ! "$a" = "$b" ]]; then
           echo '$a != $b <= WRONG!'
       else
           echo '$a = $b <= RIGHT!'
       fi

       echo -n 'Current test: [[ $a > $c ]] '
       if [[ $a > $c ]]; then
           echo '$a > $c <= WRONG!'
       else
           echo '$a < $c <= RIGHT!'
       fi

       echo -n 'Current test: [[ $c < $b ]] '
       if [[ $c < $b ]]; then
           echo '$c < $b <= WRONG!'
       else
           echo '$c > $b <= RIGHT!'
       fi

       # See anything missing?
    #+END_SRC

     #+RESULTS:
     : Current test: [[ $a = $b ]] $a = $b <= RIGHT!
     : Current test: [[ $a == $b ]] $a == $b <= RIGHT!
     : Current test: [[ "$a" != "$b" ]] $a = $b <+ RIGHT!
     : Current test: [[ ! "$a" = "$b" ]] $a = $b <= RIGHT!
     : Current test: [[ $a > $c ]] $a < $c <= RIGHT!
     : Current test: [[ $c < $b ]] $c > $b <= RIGHT!

     What about <=  and >= ?
     They work slightly different.
     Note that previous operator : > < can also be used the same way
     #+BEGIN_SRC bash :results output :exports code :tangle intComparisonCont.sh :tangle-mode (identity #o0755) :cmdline 2>&1
       #!/bin/bash

       # Integer comparison
       a=1
       b=1
       c=2

       ## Does not work with [[ ... ]]
       echo -n 'Current test: (( $a >= $c )) '
       if (( $a >= $c )); then
           echo '$a >= $c <= WRONG!'
       else
           echo '$a <= $c <= RIGHT!'
       fi

       echo -n 'Current test: (( $c <= $b )) '
       if (( $c <= $b )); then
           echo '$c <= $b <= WRONG!'
       else
           echo '$c >= $b <= RIGHT!'
       fi


       # As mentioned, previous operators works with this format:
       echo "Attempting previous test with (( ... ))"
       echo -n 'Current test: (( $a = $b )) '
       if (( $a = $b )); then
           echo '$a = $b <= RIGHT!'
       else
           echo '$a != $b <= WRONG!'
       fi

       echo -n 'Current test: (( $a == $b )) '
       if (( $a == $b )); then
           echo '$a == $b <= RIGHT!'
       else
           echo '$a != $b <= WRONG!'
       fi

       echo -n 'Current test: (( "$a" != "$b" )) '
       if (( "$a" != "$b" )); then
           echo '$a != $b <= WRONG!'
       else
           echo '$a = $b <+ RIGHT!'
       fi
       echo -n 'Current test: (( ! "$a" = "$b" )) '
       if (( ! "$a" = "$b" )); then
           echo '$a != $b <= WRONG!'
       else
           echo '$a = $b <= RIGHT!'
       fi

       echo -n 'Current test: (( $a > $c )) '
       if (( $a > $c )); then
           echo '$a > $c <= WRONG!'
       else
           echo '$a < $c <= RIGHT!'
       fi

       echo -n 'Current test: (( $c < $b )) '
       if (( $c < $b )); then
           echo '$c < $b <= WRONG!'
       else
           echo '$c > $b <= RIGHT!'
       fi

    #+END_SRC

     #+RESULTS:
     #+begin_example
     Current test: (( $a >= $c )) $a <= $c <= RIGHT!
     Current test: (( $c <= $b )) $c >= $b <= RIGHT!
     Attempting previous test with (( ... ))
     Current test: (( $a = $b )) /tmp/babel-16833Kcr/sh-script-16833rgG: line 28: ((: 1 = 1 : attempted assignment to non-variable (error token is "= 1 ")
     $a != $b <= WRONG!
     Current test: (( $a == $b )) $a == $b <= RIGHT!
     Current test: (( "$a" != "$b" )) $a = $b <+ RIGHT!
     Current test: (( ! "$a" = "$b" )) /tmp/babel-16833Kcr/sh-script-16833rgG: line 48: ((: ! 1 = 1 : attempted assignment to non-variable (error token is "= 1 ")
     $a = $b <= RIGHT!
     Current test: (( $a > $c )) $a < $c <= RIGHT!
     Current test: (( $c < $b )) $c > $b <= RIGHT!
     #+end_example

     Has you can see, usin (( ... )) format offer results that are more like other languages, single = sign attempts an assignement. The rest works fine.

     :IN_SHORT:
     When doing binary comparison, use [ ] and bash operator ( -eq -lt -ge ... )
     Use (( ... )) to use < > <= ... 
     Always a good habit to quote your variable.
     :END:

**** String Comparison
      Compare to see if 2 strings are equal:
      #+BEGIN_SRC  bash :results output :exports code :tangle strComparison.sh :tangle-mode (identity #o0755) :cmdline 2>&1
        #!/bin/bash

        str1="Hello"
        str2="Hello"
        str3="Hello world!"
        str5="abcdef"
        str6="abcdea"

        echo "Running test with [ ... ]"
        if [ $str1 = $str2 ]; then # Note the spaces [ ... = ... ];
            echo '$str1: '$str1' = $str2: '$str2
        else
            echo "This test 1 should not fail."
        fi

        if [ $str1 == $str2 ]; then
            echo '$str1: '$str1' = $str2: '$str2
        else
            echo "This test 2 should not fail."
        fi

        if [ "$str1" = "$str2" ]; then
            echo '"$str1": '$str1' = "$str2": '$str2
        else
            echo "This test 3 should not fail."
        fi

        if [ "$str1" == "$str2" ]; then
            echo '"$str1": '$str1' == "$str2": '$str2
        else
            echo "This test 4 should not fail."
        fi

        if [ "$str1" != "$str3" ]; then
            echo '"$str1": '$str1' != $"str2": '$str3
        else
            echo "This test 4 should not fail."
        fi

        if [ ! "$str1" = "$str3" ]; then
            echo '"$str1": ! '$str1' = $"str2": '$str3
        else
            echo "This test 5 should not fail."
        fi

        echo ""
        echo "Running same test with [[ ... ]]"
        if [[ $str1 = $str2 ]]; then
            echo '$str1: '$str1' = $str2: '$str2
        else
            echo "This test 6 should not fail."
        fi

        if [[ $str1 == $str2 ]]; then
            echo '$str1: '$str1' == $str2: '$str2
        else
            echo "This test 7 should not fail."
        fi

        if [[ "$str1" = "$str2" ]]; then
            echo '"$str1": '$str1' = "$str2": '$str2
        else
            echo "This test 8 should not fail."
        fi

        if [[ "$str1" == "$str2" ]]; then
            echo '"$str1": '$str1' == "$str2": '$str2
        else
            echo "This test 9 should not fail."
        fi

        if [[ "$str1" != "$str3" ]]; then
            echo '"$str1": '$str1' != "$str3": '$str3
        else
            echo "This test 10 should not fail."
        fi

        if [[ ! "$str1" = "$str3" ]]; then
            echo '"$str1": ! '$str1' = "$str3": '$str3
        else
            echo "This test 11 should not fail."
        fi

        echo ""
        echo "Running same test with (( ))"
        ## Lets use (( ))
        if (( $str1 = $str2 )); then
            echo '$str1: '$str1' = $str2: '$str2
        else
            echo "This test 12 should not fail."
        fi

        if (( $str1 == $str2 )); then
            echo '$str1: '$str1' = $str2: '$str2
        else
            echo "This test 13 should not fail."
        fi
        if (( $str1 = $str3 )); then
            echo '$str1: '$str1' = $str3: '$str3
        else
            echo "This test 14 fails as it should."
        fi

        if (( $str1 == $str3 )); then
            echo '$str1: '$str1' = $str2: '$str3
        else
            echo "This test 15 fails as it should."
        fi

        fi

        if (( "$str1" = "$str2" )); then
            echo '"$str1": '$str1' = "$str2": '$str2
        else
            echo "This test 16 should not fail."
        fi

        if (( "$str1" == "$str2" )); then
            echo '"$str1": '$str1' == "$str2": '$str2
        else
            echo "This test 17 should not fail."
        fi

        if (( "$str1" != "$str3" )); then
            echo '"$str1": '$str1' != "$str3": '$str3
        else
            echo "This test 18 should not fail."
        fi

        if [ ! "$str1" = "$str3" ]; then
            echo '"$str1": '$str1' != "$str3": '$str3
        else
            echo "This test 19 should not fail."
        fi


        ### Operator < > refer to alphabetical order

        if [[ $str5 > $str6 ]]; then # note double [[ ]]
            echo '$str5: '$str5' > $str6: '$str6
            echo "It is greater then (Comes later) in alphabetical order"
        fi

        if [[ $str6 < $str5 ]]; then
            echo '$str6: '$str6' < $str5: '$str5
        fi

        if [ $str5 \> $str6 ]; then # Escape > or < when using single []
            echo '$str5: '$str5' > $str6: '$str6
        fi

      #+END_SRC

      #+RESULTS:

      Single or double bracket are good.

      Checking if a string is null or not null -z -n

      #+BEGIN_SRC  bash :results output :exports code :tangle strComparison.sh :tangle-mode (identity #o0755) :cmdline 2>&1
        #!/bin/bash

        str=""
        declare str2
        if [ -z $str ]; then
            echo '$str is null'
        fi
        if [ -z $str2 ]; then
            echo '$str2 is null'
        fi
        if [ -z $str3 ]; then
            echo '$str3 is null, it is not even declared.'
        fi

        str="hello"

        if [ -n $str ]; then
            echo "Now str is not null: $str"
        fi
      #+END_SRC

      #+RESULTS:

** Case statement
   http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html
   Yes case statement works with strings.
   Structure
   #+BEGIN_SRC bash :results output :export none

      case EXPR in
          opt1)
              ...
              ...
              ;;
          opt2)
              ...
              ;;
      esac
    #+END_SRC

   Here is a simple example:
   :README:
      Due to user input this script will not run properly in evaluation mode.
      Export the code section with C-u C-c C-v t
      Then proceed to execute simpleCase.sh
    :END:
   #+BEGIN_SRC bash :results output :export code :tangle simpleCase.sh  :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash
     echo -n "Press a number between 0 - 9 or 567 or anything else or 76."
     read val # Reads user input and store in $val. More on read later.

     case $val in
         1)
             echo "You pressed 1."
             ;;
         2)
             echo "You pressed 2."
             ;;
         3)
             echo "You pressed 3."
             ;;
         4)
             echo "You pressed 4"
             ;;
         [567])
             echo "You pressed 5 6 or 7"
             ;;
         8|9|0)
             echo "You pressed 8 9 or 0"
             ;;
         567)
             echo "You pressed 567"
             ;;
         ,*)
             echo "Not what I asked for"
             ;;
         76)
             echo "This will never be reached. Or anything after it."
             ;;
     esac
    #+END_SRC


* Loops
** For loop
   http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_01.html
   for ITEMS in LIST; do
     ...
   done
   Example: Loop through an array
   #+BEGIN_SRC bash :results output :export code :tangle forLoop.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     declare -a myArray=(1 2 4 3 5 6 7)

     for item in ${myArray[@]}; do
         echo $item
     done
   #+END_SRC

   #+RESULTS:
   : 1
   : 2
   : 4
   : 3
   : 5
   : 6
   : 7

   Example: Loop through arguments supply on the command line.
   #+BEGIN_SRC bash :results output :export code :tangle loopArgs.sh :tangle-mode (identity #o0755) :cmdline arg1 myarg 3 2>&1
     #!/bin/bash

     argsLen=${#@}
     if [ $argsLen = 0 ]; then
         echo "Supply a serie of arguments."
         exit 1
     fi
     echo "Arguments length: $argsLen"
     for arg in ${@}; do
         echo $arg
     done
   #+END_SRC

   #+RESULTS:
   : Arguments length: 3
   : arg1
   : myarg
   : 3

** While loop
   http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html

   Example: Loop through an array
   #+BEGIN_SRC bash :results output :export code :tangle whileLoop.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     declare -a myArray=(1 2 4 3 5 6 7)

     x=0
     arrLen=${#myArray[@]}
     echo "arrLen: $arrLen"

     while [[ $x < $arrLen ]]; do
         echo ${myArray[$x]}
         ((x++))
     done

     # Same loop, but using single [] and bash operator -lt
     x=0
     while [ $x -lt $arrLen ]; do
         echo ${myArray[$x]}
         ((x++))
     done
   #+END_SRC

   #+RESULTS:
   #+begin_example
   arrLen: 7
   1
   2
   4
   3
   5
   6
   7
   1
   2
   4
   3
   5
   6
   7
   #+end_example

** until loop
   http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_03.html

   Until loop is very similar to while except that it execute until the test resolves true.
   #+BEGIN_SRC bash :results output :export code :tangle untilLoop.sh :tangle-mode (identity #o0755) :cmdline 2>&1
     #!/bin/bash

     myArray=(1 2 3 4 5 6 7 8 9 0)
     arrLen=${#myArray[@]}
     x=0
     until [[ $x = $arrLen ]]; do
         echo ${myArray[$x]}
         ((x++))
     done
   #+END_SRC

   #+RESULTS:
   #+begin_example
   1
   2
   3
   4
   5
   6
   7
   8
   9
   0
   #+end_example

** IO redirection and loop
   http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_04.html
*** Input redirection
    Another way to control a loop is by specifying a file to read the input from. Usually the command read is used for this.
    As long as input are fed into the loop, it continues, when it stop coming in, the loop quits.
    This allow for some pretty nifty scripts, when you combine this knowledge with a good understanding of files type, file descriptor and sockets,
    you can control a loop by feeding data from a file on a remote computer for example.

    :README:
    Press C-c C-c on the #+BEGIN_SRC.
    Help for the read command will display in #+RESULTS:
    :END:
    #+NAME helpRead
    #+BEGIN_SRC bash :results output :export none :tangle no :epiloge "read --help"
    #!/bin/bash
    cat - < <(read --help)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    read: read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]
        Read a line from the standard input and split it into fields.

        Reads a single line from the standard input, or from file descriptor FD
        if the -u option is supplied.  The line is split into fields as with word
        splitting, and the first word is assigned to the first NAME, the second
        word to the second NAME, and so on, with any leftover words assigned to
        the last NAME.  Only the characters found in $IFS are recognized as word
        delimiters.

        If no NAMEs are supplied, the line read is stored in the REPLY variable.

        Options:
          -a array	assign the words read to sequential indices of the array
            variable ARRAY, starting at zero
          -d delim	continue until the first character of DELIM is read, rather
            than newline
          -e	use Readline to obtain the line in an interactive shell
          -i text	use TEXT as the initial text for Readline
          -n nchars	return after reading NCHARS characters rather than waiting
            for a newline, but honor a delimiter if fewer than
            NCHARS characters are read before the delimiter
          -N nchars	return only after reading exactly NCHARS characters, unless
            EOF is encountered or read times out, ignoring any
            delimiter
          -p prompt	output the string PROMPT without a trailing newline before
            attempting to read
          -r	do not allow backslashes to escape any characters
          -s	do not echo input coming from a terminal
          -t timeout	time out and return failure if a complete line of
            input is not read within TIMEOUT seconds.  The value of the
            TMOUT variable is the default timeout.  TIMEOUT may be a
            fractional number.  If TIMEOUT is 0, read returns
            immediately, without trying to read any data, returning
            success only if input is available on the specified
            file descriptor.  The exit status is greater than 128
            if the timeout is exceeded
          -u fd	read from file descriptor FD instead of the standard input

        Exit Status:
        The return code is zero, unless end-of-file is encountered, read times out
        (in which case it's greater than 128), a variable assignment error occurs,
        or an invalid file descriptor is supplied as the argument to -u.
    #+end_example

    #+BEGIN_SRC bash :results output :export code :tangle ioLoop1.sh  :tangle-mode (identity #o0755)
      #!/bin/bash

      # First lets create a file with multiple lines of content.
      destFile=/tmp/tmpFile # change if you wish.
      touch $destFile #Create the file.
      # I redirect the output stderr and stdout  into a file

      find / -name sys* > $destFile 2>&1

      lineCount=0

      # Now read the file and prints the line count.
      # -r, If there are \, do not allow it to escape any character
      while read -r line; do
          ((lineCount++))
      done < $destFile # Input redirection.
      echo "I got $lineCount lines in $destFile"
      rm $destFile #Cleanup

      # We don't have to create a file, we can use process substitution.
      lineCount=0
      while read -r line; do
          ((lineCount++))
      done < <(find / -name sys*) # Using process substitution
      echo "I got $lineCount lines in $destFile"
    #+END_SRC

    #+RESULTS:
    : I got 7229 lines in /tmp/tmpFile
    : I got 5892 lines in /tmp/tmpFile

** Break and continue
   http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_05.html
*** Break is used to stop a loop before its normal ending.
    #+BEGIN_SRC bash :results output :export code :tangle userBreak.sh  :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      function processCmd {
          local cmd=""
          for part in $@; do
              cmd=$cmd" "$part
          done
          eval "$cmd"
          return $? # Return the return value of eval

      }

      while [ true ]; do
          echo -n ">>> "
          read u
          case $u in
              quit)
                  # Enter the command exit will also cause the loop to break.
                  break
                  ;;
              ,*)
                  processCmd $u
                  if [[ $? > 0 ]]; then # We have an error
                      echo "Error."
                  fi
                  ;;
          esac
      done
    #+END_SRC

*** Continue
    The continue statement resumes iteration of for, while and until loop.
    They also act the same for select loop which will be seen later.
    When used in a for loop, the controlling variable takes on the value of the next element in the list.
    When used in a while or until construct, execution resumes with TEST-COMMAND at the top of the loop.
    #+BEGIN_SRC bash :results output :export code :tangle contLoop.sh  :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      declare -a myArr=(1 2 3 4 5 6 7)
      for x in ${myArr[@]}; do
          if [[ $x = 3 ]]; then
              echo "x=$x, sending continue"
              continue;
          fi
          echo "x=$x, all is normal"
      done
    #+END_SRC

    #+RESULTS:
    : x=1, all is normal
    : x=2, all is normal
    : x=3, sending continue
    : x=4, all is normal
    : x=5, all is normal
    : x=6, all is normal
    : x=7, all is normal

    Here is an example with a while loop. Note that by commenting a single line, this loop will become infinite.
    #+BEGIN_SRC bash :results output :export code :tangle contInfinit.sh  :tangle-mode (identity #o0755) :cmdline 2>&1
      #!/bin/bash

      declare -a myArr=(1 2 3 4 5 6 7)

      x=0

      # This loop will no get passed 3, it will continue forever
      while [[ $x < ${#myArr[@]} ]]; do
          if [[ $x = 3 ]]; then
              echo "x=$x, sending continue"
              #((x++)) # without this the loop is infinit. continue in a while loop does not move the the next item.
              continue;
          fi
          echo "x=$x, all is normal"
          ((x++))
      done


    #+END_SRC

    #+RESULTS:
    : x=0, all is normal
    : x=1, all is normal
    : x=2, all is normal
    : x=3, sending continue
    : x=4, all is normal
    : x=5, all is normal
    : x=6, all is normal



* Passing arguments to your scripts
  Passing argument to your scripts works similar to passing args to function.
  Arguments are access from $1 ...

  Example of looping through arguments with for loop.
  #+BEGIN_SRC bash :results output :export code :tangle argsForLoop.sh  :tangle-mode (identity #o0755) :cmdline myArg1 myArg2 my arg3 2>&1
    #!/bin/bash

    for i in $@; do
        echo $i
    done

  #+END_SRC

  #+RESULTS:
  : myArg1
  : myArg2
  : my
  : arg3

  With a while

  #+BEGIN_SRC bash :results output :export code :tangle argsWhileLoop.sh  :tangle-mode (identity #o0755) :cmdline hello how are you 2>&1
    #!/bin/bash
    x=0
    args=($@) # Assign arguments into array, separated by space.
    while [[ $x < ${#args[@]} ]]; do
        echo ${args[$x]}
        ((x++))
    done

  #+END_SRC

  #+RESULTS:
  : hello
  : how
  : are
  : you

** How to implement linux style arguments into my scripts.
   There are a few way that are considered commons.

*** Space separated
    Usage: script -{short option} {value} --{long option} {value}
    This does not handle combined options
    #+BEGIN_SRC bash :results output :export code :tangle argsWhileLoop.sh  :tangle-mode (identity #o0755) :cmdline -d o rw,ext4,0755 --file /tmp/test  2>&1
      #!/bin/bash

      declare option file debug
      ## This technique uses a key, value technique.
      ## It handles short and long options.
      while [[ $# > 0 ]]; do
          key="$1" ## It will always be $1
          case $key in
              -o|--option)
                  option="$2"
                  # Shift will shift the params by 2, removing our last 2 from the list. 
                  shift 2
                  ;;
              -f|--file)
                  file="$2"
                  shift 2
                  ;;
              -d| --debug)
                  debug=1
                  shift ## debug does not take an argument, we only shift 1 item.
                  ;;
              ,*)
                  echo "Unkown option $key"
                  shift
                  ;;
          esac
      done
      echo "Done passing arguments."
      echo "Option: $option"
      echo "File: $file"
      echo "Debug: $debug"
    #+END_SRC

    #+RESULTS:
    : Unkown option -do
    : Unkown option rw,ext4,0755
    : Done passing arguments.
    : Option: 
    : File: /tmp/test
    : Debug: 

*** = Separated
    Usage: script -{short option}={value} --{long option}={value}
    Does not handles combined options.
    #+BEGIN_SRC bash :results output :export code :tangle argsWhileLoop.sh  :tangle-mode (identity #o0755) :cmdline -o=rw,ext4,0755 --file=/tmp/test 2>&1
      #!/bin/bash

      declare option file
      ## It handles short and long options.
      for i in "$@"; do
          case $i in
              -o=*|--option=*)
                  option="${i#*=}"
                  shift
                  ;;
              -f=*|--file=*)
                  file="${i#*=}"
                  shift
                  ;;
              ,*)
                  echo "Unkown option $i"
                  shift
                  ;;
          esac
      done
      echo "Done passing arguments."
      echo "Option: $option"
      echo "File: $file"
    #+END_SRC

    #+RESULTS:
    : Done passing arguments.
    : Option: rw,ext4,0755
    : File: /tmp/test

*** With getopts
    Note: Getopts handles only short options.
    Note: Handles chained options like: -vfo
    Reference: https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html Scroll down to getopts
    Note: man entry for getopt is not the same.

    Usage: getopts optstring name [args]

**** Usage
    Getopts is a bash builtin. optstring contains the option char to look for. Example, "ofg" means we are looking for short options -o -f -g or any combination -go or -fgo ...
    #+BEGIN_SRC bash :results output :export code :tangle getoptsSimple.sh  :tangle-mode (identity #o0755) :cmdline -x -o 2>&1
      #!/bin/bash

      while getopts "ofg" opt; do
          echo $opt
      done
    #+END_SRC

    #+RESULTS:
    : /tmp/babel-16833Kcr/sh-script-16833WD1: illegal option -- x
    : ?
    : o

    If a character is followed by a colon, the option is expected to have an argument.
    In such case, getopts places the argument in variable OPTARG
    #+BEGIN_SRC bash :results output :export code :tangle getoptsWithArgs.sh  :tangle-mode (identity #o0755) :cmdline -o -g -f  /var/log/syslog 2>&1
      #!/bin/bash
      declare fVal oVal=0 gVal=0

      # In this example, option f is expected to have an argument.
      while getopts "of:g" opt; do
          case $opt in
              f)
                  fVal=$OPTARG
                  ;;
              o)
                  oVal=1
                  ;;
              g)
                  gVal=1
                  ;;
          esac
      done
      echo "Options: fVal:$fVal oVal:$oVal gVal:gVal"
    #+END_SRC

    #+RESULTS:
    : Options: fVal:/var/log/syslog oVal:1 gVal:gVal

    Everytime it is invoke, getops places the next option into variable and the index of the next argument to be processed in OPTIND.
    While OPTIND will be set to 1 everytime the shell script is involved, it does not reset itself automatically.
    If you are to call getopts multiple time, OPTIND has to be reset manually.
    #+BEGIN_SRC bash :results output :export code :tangle getoptsOPTIND.sh  :tangle-mode (identity #o0755) :cmdline -o -g -f /var/log/syslog 2>&1
      #!/bin/bash
      declare fVal oVal=0 gVal=0

      ## OPTIND is set to 1 when script is started
      echo "OPTIND: $OPTIND"

      while getopts "of:g" opt; do
          echo "Inside while loop. OPTIND: $OPTIND"
          case $opt in
              f)
                  fVal=$OPTARG
                  ;;
              o)
                  oVal=1
                  ;;
              g)
                  gVal=1
                  ;;
          esac
      done

      echo "Passed while loop. OPTIND: $OPTIND"

      echo "Attempting to redo same loop without reset of OPTIND"

      while getopts "of:g" opt; do
          echo "Inside second while loop. OPTIND: $OPTIND" # You will not see this message at all.
          case $opt in
              f)
                  fVal=$OPTARG
                  ;;
              o)
                  oVal=1
                  ;;
              g)
                  gVal=1
                  ;;
          esac
      done

      echo "Second while loop finished."
    #+END_SRC

    #+RESULTS:
    : OPTIND: 1
    : Inside while loop. OPTIND: 2
    : Inside while loop. OPTIND: 3
    : Inside while loop. OPTIND: 5
    : Passed while loop. OPTIND: 5
    : Attempting to redo same loop without reset of OPTIND
    : Second while loop finished.

**** getopts and Errors
     By default, error message are printed when invalid options or missing options args.

     This script does not supply an argument for option f, getopts will display error message.
     #+BEGIN_SRC bash :results output :export code :tangle getoptsErr.sh  :tangle-mode (identity #o0755) :cmdline -o -g -f 2>&1
      #!/bin/bash
      declare fVal oVal=0 gVal=0

      ## Good habit just in case for some reason it has not been reset.
      OPTIND=1

      while getopts "of:g" opt; do
          case $opt in
              f)
                  fVal=$OPTARG
                  ;;
              o)
                  oVal=1
                  ;;
              g)
                  gVal=1
                  ;;
              ,*)
                  # Unknown option
                  ;;
          esac
      done

      echo "Options: fVal:$fVal oVal:$oVal gVal:gVal"
     #+END_SRC

     #+RESULTS:
     : /tmp/babel-16833Kcr/sh-script-16833jiX: option requires an argument -- f
     : Options: fVal: oVal:1 gVal:gVal

     If the first char in optstring is a colon, silent mode is used:
     #+BEGIN_SRC bash :results output :export code :tangle getoptsErrSilent.sh  :tangle-mode (identity #o0755) :cmdline -o -g -f 2>&1
      #!/bin/bash
      declare fVal oVal=0 gVal=0

      ## Good habit just in case for some reason it has not been reset.
      OPTIND=1

      while getopts ":of:g" opt; do
          case $opt in
              f)
                  fVal=$OPTARG
                  ;;
              o)
                  oVal=1
                  ;;
              g)
                  gVal=1
                  ;;
              ,*)
                  # Unknown option
                  ;;
          esac
      done

      echo "Options: fVal:$fVal oVal:$oVal gVal:gVal"
    #+END_SRC

     #+RESULTS:
     : Options: fVal: oVal:1 gVal:gVal

     If the variable OPTERR is set to 0, no error message will be printed.
     #+BEGIN_SRC bash :results output :export code :tangle getoptsOPTERR.sh  :tangle-mode (identity #o0755) :cmdline -o -g -f 2>&1
      #!/bin/bash
      declare fVal oVal=0 gVal=0

      ## Good habit just in case for some reason it has not been reset.
      OPTIND=1
      OPTERR=0
      while getopts "of:g" opt; do
          case $opt in
              f)
                  fVal=$OPTARG
                  ;;
              o)
                  oVal=1
                  ;;
              g)
                  gVal=1
                  ;;
              ,*)
                  # Unknown option
                  ;;
          esac
      done

      echo "Options: fVal:$fVal oVal:$oVal gVal:gVal"
    #+END_SRC

     #+RESULTS:
     : Options: fVal: oVal:1 gVal:gVal

     When an invalid options is found, the value ? is place in name, OPTARG is unset and a diagnostic message is printed by getopts
     This code block will supply an invalid option x
     #+BEGIN_SRC bash :results output :export code :tangle getoptsInvalidOpt.sh  :tangle-mode (identity #o0755) :cmdline -o -g -x 2>&1
       #!/bin/bash
       declare fVal oVal=0 gVal=0

       ## Good habit just in case for some reason it has not been reset.
       OPTIND=1
       OPTERR=1 ## Makes sure that error messages will be printed unless suppressed in optstring
       while getopts "of:g" opt; do
           case $opt in
               f)
                   fVal=$OPTARG
                   ;;
               o)
                   oVal=1
                   ;;
               g)
                   gVal=1
                   ;;
               "?")
                   echo "Invalid option detected, getopts will display an error message to."
                   echo "opt = $opt"
                   echo "OPTARG = $OPTARG"
                   ;;
               ,*)
                   # Unknown option
                   ;;
           esac
       done

    #+END_SRC

     #+RESULTS:
     : /tmp/babel-16833Kcr/sh-script-16833WfF: illegal option -- x
     : Invalid option detected, getopts will display an error message to.
     : opt = ?
     : OPTARG = 

     If getopts is in silent mode, OPTARG is set to the option char found.
     #+BEGIN_SRC bash :results output :export code :tangle getoptsInvalidOptSilent.sh  :tangle-mode (identity #o0755) :cmdline -o -g -x 2>&1
       #!/bin/bash
       declare fVal oVal=0 gVal=0

       ## Good habit just in case for some reason it has not been reset.
       OPTIND=1
       OPTERR=0 # Setting this to 1 does not set getopts in silent mode. But it does suppress error messages.
       while getopts ":of:g" opt; do
           case $opt in
               f)
                   fVal=$OPTARG
                   ;;
               o)
                   oVal=1
                   ;;
               g)
                   gVal=1
                   ;;
               "?")
                   echo "Invalid option detected, getopts will NOT display an error message."
                   echo "opt = $opt"
                   echo "OPTARG = $OPTARG"
                   echo "Option $OPTARG is not a valid one."
                   ;;
               ,*)
                   # Unknown option
                   ;;
           esac
       done

     #+END_SRC

     #+RESULTS:
     : Invalid option detected, getopts will NOT display an error message.
     : opt = ?
     : OPTARG = x
     : Option x is not a valid one.

     If a required argument is missing and getopts is NOT silent, ? is placed in name, OPTARG is unset and diagnostic message is printed.
     #+BEGIN_SRC bash :results output :export code :tangle getoptsInvalidOptNotSilent.sh  :tangle-mode (identity #o0755) :cmdline -o -g -f 2>&1
       #!/bin/bash
       declare fVal oVal=0 gVal=0

       ## Good habit just in case for some reason it has not been reset.
       OPTIND=1
       OPTERR=0 
       while getopts "of:g" opt; do
           case $opt in
               f)
                   fVal=$OPTARG
                   ;;
               o)
                   oVal=1
                   ;;
               g)
                   gVal=1
                   ;;
               "?")
                   echo "Missing argument detected, getopts will display an error message."
                   echo "opt = $opt"
                   echo "OPTARG = $OPTARG"
                   echo "Option $OPTARG requires an argument."
                   ;;
               ,*)
                   # Unknown option
                   ;;
           esac
       done

     #+END_SRC

     #+RESULTS:
     : Missing argument detected, getopts will display an error message.
     : opt = ?
     : OPTARG = 
     : Option  requires an argument.

     If a required argument is missing and getopts is silent, : is placed in name, OPTARG is set to the option found and diagnostic message is NOT printed.
     #+BEGIN_SRC bash :results output :export code :tangle getoptsInvalidOptSilent.sh  :tangle-mode (identity #o0755) :cmdline -o -g -f 2>&1
       #!/bin/bash
       declare fVal oVal=0 gVal=0

       ## Good habit just in case for some reason it has not been reset.
       OPTIND=1
       OPTERR=0 # Setting this to 1 will only supress error message, getopts will NOT be in silent mode.
       while getopts ":of:g" opt; do
           case $opt in
               f)
                   fVal=$OPTARG
                   ;;
               o)
                   oVal=1
                   ;;
               g)
                   gVal=1
                   ;;
               ":") # Looking for ? will not work in this case.
                   echo "Missing argument detected, getopts will NOT display an error message."
                   echo "opt = $opt"
                   echo "OPTARG = $OPTARG"
                   echo "Option $OPTARG requires an argument."
                   ;;
               ,*)
                   # Unknown option
                   ;;
           esac
       done

     #+END_SRC

     #+RESULTS:
     : Missing argument detected, getopts will NOT display an error message.
     : opt = :
     : OPTARG = f
     : Option f requires an argument.




* Making menus with the select built-in
  :README:
  Code block in this section creates interactive script, make sure to export before and run them in a shell
  C-u C-c C-v t
  :END:
  The select makes it easy to display interactive menu to the user in CLI

  select WORD [in LIST]; do ... ; done

  LIST is expanded and a list of items is generated from it. The expansion is printed to stderr
  Due to the interactive nature of this code, it must be exported C-u C-c C-v t
  #+BEGIN_SRC bash :results output :export code :tangle simpleSelect.sh :tangle-mode (identity #o0755) :cmdline 2>&1
    #!/bin/bash

    # The following script will give you a menu of all the directory in your home directory.
    # After making a selection, it will list all files in that directory or quit.
    # Due to the interactive nature of this script, it will need to be exported.

    while true; do
        select DIR in ~/*/ "QUIT"; do
            if [[ "$DIR" = "QUIT" ]]; then
                exit 0
            fi
               ls -l $DIR
        done
    done
  #+END_SRC

** Submenus
   Nested select statement creates submenus
   Due to the interactive nature of this code, it must be exported C-u C-c C-v t
  #+BEGIN_SRC bash :results output :export code :tangle selectSubMenu.sh :tangle-mode (identity #o0755) :cmdline 2>&1
    #!/bin/bash

    # The following script will give you a menu with the content of your home directory.
    # After making a selection, if it's a file it will print the content to stdout (Carefull with your selection, zip files are long to print)
    # If it is a directory, it will enter the folder and list the content.
    # In that submenu, you can go back. If you select a directory, it's content will be listed.
    # Due to the interactive nature of this script, it will need to be exported.

    while true; do
        ## pushd is a better way in a script to change directory.
        ## Removing >/dev/null will cause pushd to print the directory stack when it is manipulated.
        pushd ~ >/dev/null # Push ! directory on top of the stack.
        select DIR in * "QUIT"; do
            if [[ "$DIR" = "QUIT" ]]; then
                exit 0
            elif [ -d $DIR ]; then
                pushd $DIR >/dev/null
                select subdir in * "BACK"; do
                    if [[ "$subdir" = "BACK" ]]; then
                        break
                    elif [ -f $subdir ]; then
                        cat $subdir # Prints the content of the file to stdout
                    elif [ -d $subdir ]; then
                        ls -l $subdir
                    else
                        echo "I don't know what to do with that."
                    fi
                done
                popd >/dev/null
            elif [ -f $DIR ]; then
                cat $DIR
            else
                echo "I don't know what to do with that."
            fi

        done
        popd >/dev/null # Revert directory stack
    done
  #+END_SRC


* Projects

:README:
You will learn more tricks by looking at my version of the project.
Some missing bash notion can create some challenges doing this project. This is normal, we just started scripting.
For example, select splits the list based on a bash variable IFS. IFS default setting is space.
This cause select for each word in mainMenu. To fix this behavior, we set IFS to ; before our main loop.
Unsetting IFS will reset to its default behavior.
:END:

** Create a simple file manager

Most of the src code below cannot run in evaluation mode without changin src block headers.
To export, place your cursor below #+NAME: scriptExport and press C-u C-c C-v t
Attempting to export on any other code block will not work. This is a setup that allows exportation of the project only without export all code block.
The project will also export when exporting all code block.

#+NAME: scriptExport
#+BEGIN_SRC bash :eval no :tangle myFm.sh :tangle-mode (identity #o0755) :noweb tangle
  #!/bin/bash

  <<scriptHeader>>

  <<exitDirectory>>

  <<enterDirectory>>

  <<listContent>>

  <<createDirectory>>

  <<removeDirectory>>

  <<createFile>>

  <<removeFile>>

  <<QUIT>>

  <<Main>>
#+END_SRC

#+NAME: Main
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :noweb strip-export :export no
  ###
  # To allow for our enterDirectory function to have a "Up" feature. Our directory stack need to have every part from the root folder.
  # If we don't, the script will be restricted to the current directory and below.
  # This is because the directory stack base entry will be the current directory. Any attempt to popd this entry will not result in the parent directory
  # Note that our current directory will remain at the base of the stack
  currentTree=$(pwd)
  IFS=/
  echo "Clear the directory stack."
  dirs -c
  if [[ $? > 0 ]]; then
      >&2 echo "Error clearing directory stack. Cannot continue."
      exit 1
  fi

  echo "Rebuilding it."
  first=0 # our first pushd requires a / in front.
  for part in $currentTree; do
      if [[ $first > 0 ]]; then
          pushd $part
      else
          pushd "/$part"
          first=1
      fi
  done
  unset IFS
  echo $currentTree
  IFS=;
  while true; do
      select OPT in ${mainMenu[@]}; do
          case $OPT in
              "List Content")
                  listContent
                  ;;
              "Create File")
                  createFile
                  ;;
              "Create Directory")
                  createDirectory
                  ;;
              "Remove File")
                  removeFile
                  ;;
              "Remove Directory")
                  removeDirectory
                  ;;
              "Enter Directory")
                  enterDirectory
                  ;;
              "Quit")
                  Quit
                  ;;
              ,*)
                  >&2 echo "Selection not understood."
                  ;;
          esac
      done
  done
#+END_SRC

#+NAME: scriptHeader
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  declare -f enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit
  declare -a mainMenu=("List Content" "Enter Directory" "Create File" "Create Directory" "Remove File" "Remove Directory" "Quit")
#+END_SRC

#+NAME: exitDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function exitDirectory {
      popd >/dev/null # pop the top of the stack
  }

#+END_SRC

#+NAME: enterDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function enterDirectory {
      select DIR in "UP" */ "Back"; do
          case $DIR in
              "UP")
                  popd
                  break;
                  ;;
              "Back")
                  break
                  ;;
              ,*)
                  pushd $DIR
                  break;
                  ;;
          esac
      done
  }

#+END_SRC

#+NAME: listContent
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  # Called without arguments, list the content in current directory
  # Called with an argument, list the content if arg is directory
  # Complains if arg is otherwise.
  function listContent {
      if [ -z $1 ]; then
         ls -l
         return 0
      fi
      if [ -d $1 ]; then
          enterDirectory $1
          ls -l
          exitDirectory
          return 0
      fi
      >&2 echo "Error, listContent argument not understood."
      return 1
  }

#+END_SRC

#+NAME: createDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function createDirectory {
      echo -n "Enter directory name: "
      read n # read user input into var n
      if [ -f $n ]; then # File exists
          >&2 echo "Error file exists."
          return 1
      fi
      eval "mkdir -vp $n" # Attempt to create the directory
      if (( $? > 0 )); then # Return value of eval is stored in $?
          # >&2 redirects output into stderr.
          # It is good practice to redirect error message to stderr (file descriptor 2)
          >&2 echo "eval mkdir -vp $1 returned an error."
          return 1 # Return error
      fi
      echo "Directory $n created."
      return 0 # Success
  }
#+END_SRC

#+NAME: removeDirectory
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeDirectory {
      select file in * "QUIT"; do
          if [[ "$file" == "QUIT" ]]; then
              echo "Leaving."
              return 0
          fi
          if [ ! -e $file ]; then
              echo "$file does not exists."
              return 1
          fi
          if [ -f $file ]; then
              echo "$file is a regular file, doing nothing."
              return 2
          fi
          if [ -d $file ]; then
              # Checking if directory is empty
              cCount=eval "ls -A $file | wc -l"
              if [[ $cCount > 0 ]]; then
                  echo "Warning, directory not empty, doing nothing."
                  return 3
              fi
              eval "rmdir -iv $file"
              if [[ $? > 0 ]]; then
                  echo "Error with eval comand to remove directory."
                  return 4
              fi
              return 0
          fi
          >&2 echo "Unknown error, but file was not deleted."
          return 127
      done
  }
#+END_SRC

#+NAME: createFile
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function createFile {
      echo -n "Enter file name: "
      read n # read user input into var n
      if [ -e $n ]; then # File exists
          >&2 echo "Error file exists."
          return 1
      fi
      eval "touch $n" # Attempt to create the directory
      if (( $? > 0 )); then # Return value of eval is stored in $?
          # >&2 redirects output into stderr.
          # It is good practice to redirect error message to stderr (file descriptor 2)
          >&2 echo "eval touch -vp $1 returned an error."
          return 1 # Return error
      fi
      echo "File $n created."
      return 0 # Success
  }
#+END_SRC

#+NAME: removeFile
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeFile {
      select file in * "QUIT"; do
          if [[ "$file" == "QUIT" ]]; then
              echo "Leaving."
              return 0
          fi
          if [ ! -e $file ]; then
              echo "$file does not exists."
              return 1
          fi
          if [ -d $file ]; then
              echo "$file is a directory file, doing nothing."
              return 2
          fi
          if [ -f $file ]; then
              echo -e "\e[33mWARNING, THIS WILL REALLY DELETE THE FILE\e[0m"
              eval "rm -iv $file"
              if [[ $? > 0 ]]; then
                  echo "eval returned and error."
                  return 3
              fi
              echo "File deleted."
              return 0
          fi
          >&2 echo "Unknown error, but file was not deleted."
          return 3
      done
  }
#+END_SRC

#+NAME: QUIT
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function Quit {
      echo "Cleaning up."
      unset  enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit mainMenu
      exit 0
  }
#+END_SRC





** Here is another version, making more use of the select builtin

Most of the src code below cannot run in evaluation mode without changin src block headers.
To export, place your cursor below #+NAME: scriptExport and press C-u C-c C-v t
Attempting to export on any other code block will not work. This is a setup that allows exportation of the project only without export all code block.
The project will also export when exporting all code block.

#+NAME: scriptExport2
#+BEGIN_SRC bash :eval no :tangle myFm2.sh :tangle-mode (identity #o0755) :noweb tangle
  #!/bin/bash

  <<scriptHeader2>>

  <<exitDirectory2>>

  <<enterDirectory2>>

  <<listContent2>>

  <<createDirectory2>>

  <<createFile2>>

  <<rename>>

  <<removeDirectory2>>

  <<removeFile2>>

  <<enableSub>>
  
  <<createSub>>

  <<QUIT2>>

  <<Main2>>
#+END_SRC

#+NAME: scriptHeader2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  declare -f enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit
  ## Simple hack to display colored item in select.
  declare -a mainMenu=("Reload" "Create" "Quit" "..")
  declare -a subMenu
  # SELECT uses PS3 to display the default #?
  # Those are part of the Bash prompt, which will be covered soon.
  export PS3='>>> '
#+END_SRC

#+NAME: Main2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :noweb strip-export :export no
  ###
  # To allow for our enterDirectory function to have a "Up" feature. Our directory stack need to have every part from the root folder.
  # If we don't, the script will be restricted to the current directory and below.
  # This is because the directory stack base entry will be the current directory. Any attempt to popd this entry will not result in the parent directory
  # Note that our current directory will remain at the base of the stack
  currentTree=$(pwd)
  IFS=/
  echo "Clear the directory stack."
  dirs -c
  if [[ $? > 0 ]]; then
      >&2 echo "Error clearing directory stack. Cannot continue."
      exit 1
  fi

  echo -n "Rebuilding it."
  first=0 # our first pushd requires a / in front.
  for part in $currentTree; do
      if [[ $first > 0 ]]; then
          pushd $part > /dev/null
          echo -n '.'
      else
          pushd "/$part" >/dev/null
          echo -n '.'
          first=1
      fi
  done
  echo ""
  unset IFS
  echo $currentTree
  IFS=;
  while true; do
      select OPT in ${mainMenu[@]} *; do
          case $OPT in
              "List")
                  listContent
                  ;;
              "Create")
                  createSub
                  ;;
              "Quit")
                  Quit
                  ;;
              "..")
                  exitDirectory
                  break
                  ;;
              "Reload")
                  break
                  ;;
              ,*)
                  enableSub $OPT
                  if [[ $? == 0 ]]; then
                      break
                  fi
                  ;;
          esac
      done
  done
#+END_SRC

#+NAME:enableSub
#+BEGIN_SRC bash :eval no :tangle no :export no
  function enableSub {
        declare psBAK=$PS3
        declare -a subMenus
        export PS3=$'>>> '

        if [[ -d $1 ]]; then
            subMenus=("Enter" "Delete" "Back")
            select SUB in ${subMenus[@]}; do
                case $SUB in
                    "Enter")
                        enterDirectory $1
                        return 0
                        ;;
                    "Delete")
                        removeDirectory $1
                        break;
                        ;;
                    "Back")
                        $PS3=$psBAK
                        unset subMenus
                        break;
                        ;;
                    ,*)
                        echo "Unknown option."
                        ;;
                esac
            done
        fi

        if [[ -f $1 ]]; then
            subMenus=("Rename" "Delete" "Back")
            select SUB in ${subMenus[@]}; do
                case $SUB in
                    "Rename")
                        $PS3=$psBAK
                        unset subMenus
                        rename $1
                        break;
                        ;;
                    "Delete")
                        $PS3=$psBAK
                        unset subMenus
                        removeFile $1
                        break;
                        ;;
                    "Back")
                        $PS3=$psBAK
                        unset subMenus
                        break
                        ;;
                    ,*)
                        echo "Unknown option: $SUB"
                        ;;
                esac
            done
        fi
    }
#+END_SRC

#+NAME:createSub
#+BEGIN_SRC bash :eval no :tangle no :export no
    function createSub {
        declare psBAK=$PS3
        declare -a subMenus
        export PS3='Create what type? >>> '
        subMenus=("File" "Directory" "Back")
        select SUB in ${subMenus[@]}; do
            case $SUB in
                "File")
                    echo -n "File name: "
                    read f
                    createFile $f
                    unset f
                    export PS3=$psBAK
                    unset subMenus
                    break
                    ;;
                "Directory")
                    echo -n "Directory name: "
                    read n
                    createDirectory $n
                    export PS3=$psBAK
                    unset subMenus
                    break
                    unset n
                    ;;
                "Back")
                    export PS3=$psBAK
                    unset subMenus
                    break;
                    ;;
                ,*)
                    echo "Unknown option $SUB"
                    ;;
            esac
        done

    }
#+END_SRC

#+NAME: rename
#+BEGIN_SRC bash :eval no :tangle no :export no
  function rename {
      if [ -z $1 ]; then
          >&2 echo "Error rename called without arguments."
          return 1
      fi

      declare n
      while true; do
          echo -n "New name: "
          read n
          if [ ! -e $n ]; then
              break;
          fi
      done

      eval "mv -v $1 $n"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 2
      fi
      return 0
  }
#+END_SRC

#+NAME: createFile2
#+BEGIN_SRC bash :eval no :tangle no :export no
  function createFile {
      if [ -z $1 ]; then
          >&2 echo "Error create file called without arguments."
          return 1
      fi

      if [ -e $1 ]; then
          >&2 echo "Error name exists."
          return 2
      fi

      eval "touch $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 3
      fi
      return 0
  }
#+END_SRC

#+NAME: createDirectory2
#+BEGIN_SRC bash :eval no :tangle no :export no
  function createDirectory {
      if [ -z $1 ]; then
          >&2 echo "Error create directory called without arguments."
          return 1
      fi

      if [ -d $1 ]; then
          >&2 echo "Error directory exists."
          return 2
      fi

      eval "mkdir -vp $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval"
          return 3
      fi
      return 0
  }
#+END_SRC

#+NAME: exitDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function exitDirectory {
      popd >/dev/null # pop the top of the stack
  }

#+END_SRC

#+NAME: enterDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function enterDirectory {
      dir=$1
      if [ -d $dir ]; then
          pushd $dir >/dev/null
          return 0
      fi
      return 1
  }

#+END_SRC

#+NAME: removeDirectory2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeDirectory {
      dir=$1
      if [ ! -d $dir ]; then
          ## This should not happen
          return 1
      fi
      ## Check if dir is empty
      cCount=$(ls -A $dir | wc -l)
      if [[ $cCount > 0 ]]; then
          >&2 echo "Error $dir is not empty."
          return 1
      fi
      eval "rmdir -v $dir"
      res=$?
      if [[ $res > 0 ]]; then
          echo "Eval return $res"
          unset res
          return 1
      fi
      return 0
  }
#+END_SRC

#+NAME: removeFile2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function removeFile {
      if [ -z $1 ]; then
          >&2 echo "Error removeFile called without arguments."
          return 1
      fi

      echo -e "\e[33mWARNING This will really delete the file.\e[0m"
      eval "rm -iv $1"
      if [[ $? > 0 ]]; then
          echo "Error in eval."
          return 2
      fi
      return 0
  }
#+END_SRC

#+NAME: QUIT2
#+BEGIN_SRC bash :eval no :tangle no :tangle-mode (identity #o0755) :export no
  function Quit {
      echo "Cleaning up."
      unset  enterDir existDir listContent createFile removeFile createDirectory removeDirectory Quit mainMenu
      PS3=oldPS3
      unset oldPS3
      exit 0
  }
#+END_SRC

